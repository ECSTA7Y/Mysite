---
title: '垃圾短信过滤程序'
author:  
date: '2019-12-25'
slug: sms
---



<!---
[Text-Classification](https://cfss.uchicago.edu/notes/supervised-text-classification/)
--->
<p>使用文本分类的方法判别垃圾短信的方法是NLP领域的一个非常经典的应用。其实简单来讲就是让人类的自然语言转化成模型能够“读懂”的矩阵语言。其次，数据集必须有标签，这样才能使用SVM等方法进行有监督学习。</p>
<p>这篇文章是我为了熟悉NLP基本概念进行的练习。训练模型的步骤很简单。稍微有点困难的是将任何一个新的数据代入训练好的模型进行判别。这需要一定的编程技巧来解决。</p>
<p>更困难的是将训练结果产品化，做成一个交互式的用户界面，部署在网络上。让所有用户登上网页直接就能用这个模型。这就涉及到Shiny App的知识。</p>
<p>世上无难事只怕有心人。我还真把这两个功能都做出来了。其实并不需要很多的编程知识。只需要深入了解一点R就可以了。Shiny App的部署方法在文末。实际上本篇对自己也仅仅是个抛砖引玉。更强算力、更多功能的程序还需要更精深的编程知识，只会R就不够啦。这个分析我也使用同样的数据<a href="https://www.kaggle.com/rikdifos/sms-text-classification">用Python做了一遍</a>，可以做个比较。</p>
<p>还有，我以前习惯用<code>&lt;-</code>赋值，最近开始用<code>=</code>赋值，是因为<code>=</code>不仅方便还能和其他语言保持一致。于是，使用RStudio自带的Replace功能，一家伙替换掉了。</p>
<div id="首先" class="section level1">
<h1>首先…</h1>
<p>使用<code>read_csv</code>读取数据后无需使用<code>tibble</code>函数转化。<code>read_csv</code>能够直接得到<code>tibble</code>对象。不然会报错。</p>
<p>R在构建文档-词语矩阵的有许多实现方式。下面使用了<code>tm::DocumentTermMatrix</code>函数实现。在此之前，我尝试了<code>quanteda::dfm_weight</code>函数，但是在我的本地R软件中总是报错（在Kaggle上的R Notebook能够运行）。另一个可能的路径是使用<code>tidytext::unnest_tokens</code>等函数进行去除停止词、去除数字和标点符号、提取词干等一系列操作；再通过<code>tidytext::cast_dtm</code>转化成<code>DocumentTermMatrix</code>对象。但这么做会导致因变量和特征矩阵行数不一致的问题。由于我无法解决它，我采用了下面的方案。当然使用Python是非常好的选择，我在<a href="https://www.kaggle.com/rikdifos/sms-text-classification">这里</a>给出了基于Python的做法。相比R，Python的可视化能力略显不足。</p>
<p>我认为<code>tidytext</code>十分适合对文本信息进行探索和可视化，而<code>tm</code>则适合构建矩阵进行建模。如果将二者混用则可能导致问题。</p>
</div>
<div id="上代码" class="section level1">
<h1>上代码</h1>
<pre class="r"><code>library(magrittr)
library(quanteda)
library(tidytext)
library(ggplot2)
library(dplyr)
library(tm)
library(readr)
library(stringr)</code></pre>
<pre class="r"><code>sms = read_csv(&quot;E:/MaLearning/SPAM text message 20170820 - Data.csv&quot;)</code></pre>
<p>原数据共两列，其中一列记录了是否为垃圾短信的标签。垃圾邮件记为<code>spam</code>，非垃圾邮件记为<code>ham</code>。另一列是短信文本内容。其中，非垃圾邮件的比例约为0.87，垃圾邮件的比例为0.13。</p>
<pre class="r"><code>#因变量比例
sms %&gt;% count(Category)</code></pre>
<pre><code># # A tibble: 2 x 2
#   Category     n
#   &lt;chr&gt;    &lt;int&gt;
# 1 ham       4825
# 2 spam       747</code></pre>
<pre class="r"><code>#sms %$% prop.table(table(Category))[1]</code></pre>
<p>数据概览如下，数据共2列，第1列为标签，第2列为文本内容：</p>
<pre class="r"><code>smswd = sms %&gt;%
  rename(message = Message,tag=Category) %&gt;% 
  mutate(ID = row_number())
head(smswd)</code></pre>
<pre><code># # A tibble: 6 x 3
#   tag   message                                                          ID
#   &lt;chr&gt; &lt;chr&gt;                                                         &lt;int&gt;
# 1 ham   Go until jurong point, crazy.. Available only in bugis n gre~     1
# 2 ham   Ok lar... Joking wif u oni...                                     2
# 3 spam  Free entry in 2 a wkly comp to win FA Cup final tkts 21st Ma~     3
# 4 ham   U dun say so early hor... U c already then say...                 4
# 5 ham   Nah I don&#39;t think he goes to usf, he lives around here though     5
# 6 spam  FreeMsg Hey there darling it&#39;s been 3 week&#39;s now and no word~     6</code></pre>
<pre class="r"><code>Y = as.factor(smswd$tag)</code></pre>
<pre class="r"><code>smswd$message = lapply(smswd$message , iconv, &quot;UTF-8&quot;, &quot;ASCII&quot;, sub=&quot;&quot;)

smsvis = smswd %&gt;%
  unnest_tokens(word,message) %&gt;% # 分词
  filter(str_detect(word, &quot;^[a-z]+$&quot;)) %&gt;% #使用正则匹配英文
  anti_join(stop_words) %&gt;% # 去除停止词
  mutate(word = SnowballC::wordStem(word,language = &quot;english&quot;)) # 提取词干
head(smsvis)</code></pre>
<pre><code># # A tibble: 6 x 3
#   tag      ID word  
#   &lt;chr&gt; &lt;int&gt; &lt;chr&gt; 
# 1 ham       1 jurong
# 2 ham       1 crazi 
# 3 ham       1 bugi  
# 4 ham       1 world 
# 5 ham       1 la    
# 6 ham       1 buffet</code></pre>
<pre class="r"><code>library(reshape2)
library(wordcloud)
smsvis %&gt;% # 词云图，颜色代表不同类别
  count(word, tag, sort = T) %&gt;%
  acast(word ~ tag, value.var = &quot;n&quot;, fill = 0) %&gt;%
  comparison.cloud(colors = c(&quot;blue&quot;, &quot;red&quot;),max.words = 50)</code></pre>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-6"></span>
<img src="/post/SMS_spam_files/figure-html/unnamed-chunk-6-1.png" alt="可以看出垃圾信息大量使用了call、free等营销相关的词语。而普通信息则更多是日常交流用语" width="90%" />
<p class="caption">
Figure 1: 可以看出垃圾信息大量使用了call、free等营销相关的词语。而普通信息则更多是日常交流用语
</p>
</div>
<pre class="r"><code>smsvis %&gt;% # 不同类别信息的词频统计
  count(tag, word) %&gt;%
  group_by(tag) %&gt;%
  top_n(15) %&gt;%
  ggplot() +
  geom_col(aes(reorder(word, n), 
               n, fill = tag),
           show.legend = F) +
  facet_wrap(~tag, scales = &quot;free_y&quot;) +
  coord_flip()</code></pre>
<p><img src="/post/SMS_spam_files/figure-html/unnamed-chunk-7-1.png" width="90%" style="display: block; margin: auto;" /></p>
<pre class="r"><code>smsvis %&gt;% # 不同类别信息的tf-idf值
  count(tag, word) %&gt;%
  bind_tf_idf(word,tag,n) %&gt;% 
  group_by(tag) %&gt;%
  top_n(10) %&gt;%
ggplot() + 
  geom_col(aes(reorder(word,tf_idf), 
             tf_idf, fill = tag),
           show.legend = F) +
  facet_wrap(~tag, scales = &quot;free_y&quot;) +
  coord_flip()</code></pre>
<p><img src="/post/SMS_spam_files/figure-html/unnamed-chunk-7-2.png" width="90%" style="display: block; margin: auto;" /></p>
<pre class="r"><code>ms_corpus = VCorpus(VectorSource(smswd$message))

sms_dtm = DocumentTermMatrix(ms_corpus, control =
                                 list(tolower = T,
                                      removeNumbers = T,
                                      stopwords = T,
                                      removePunctuation = T,
                                      stemming = T))

dim(sms_dtm) #5572</code></pre>
<pre><code># [1] 5572 6953</code></pre>
<pre class="r"><code>sms_dtm1 = removeSparseTerms(sms_dtm, sparse = .98)
smsmat = as.matrix(sms_dtm1) # 训练数据集
dim(smsmat)</code></pre>
<pre><code># [1] 5572   51</code></pre>
<pre class="r"><code>colnames(smsmat)</code></pre>
<pre><code>#  [1] &quot;ask&quot;   &quot;back&quot;  &quot;call&quot;  &quot;can&quot;   &quot;come&quot;  &quot;day&quot;   &quot;dont&quot;  &quot;free&quot; 
#  [9] &quot;get&quot;   &quot;give&quot;  &quot;good&quot;  &quot;got&quot;   &quot;home&quot;  &quot;hope&quot;  &quot;just&quot;  &quot;know&quot; 
# [17] &quot;later&quot; &quot;like&quot;  &quot;lor&quot;   &quot;love&quot;  &quot;ltgt&quot;  &quot;make&quot;  &quot;meet&quot;  &quot;mobil&quot;
# [25] &quot;need&quot;  &quot;new&quot;   &quot;now&quot;   &quot;one&quot;   &quot;phone&quot; &quot;pleas&quot; &quot;repli&quot; &quot;say&quot;  
# [33] &quot;see&quot;   &quot;send&quot;  &quot;sorri&quot; &quot;still&quot; &quot;stop&quot;  &quot;take&quot;  &quot;tell&quot;  &quot;text&quot; 
# [41] &quot;think&quot; &quot;time&quot;  &quot;today&quot; &quot;tri&quot;   &quot;txt&quot;   &quot;want&quot;  &quot;week&quot;  &quot;well&quot; 
# [49] &quot;will&quot;  &quot;work&quot;  &quot;you&quot;</code></pre>
<p>原本的文档-词语频率矩阵有6953个特征，维度过高且过于稀疏。经过<code>removeSparseTerms</code>函数处理后保留了51个特征。</p>
</div>
<div id="算法" class="section level1">
<h1>算法</h1>
<p>朴素贝叶斯常常被用作文本分类的基线模型。因为文本数据满足每个单词相互独立。而且，一个单词的位置不依赖于另一个单词。也就是说，用于建模的文档-词语频率矩阵(DTM)各列独立，这满足了朴素贝叶斯的独立性假设。此外，为了提高准确率，我还进一步使用了支持向量机方法。支持向量机则是一种性能很强的分类器，可以实现非线性划分。</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-9"></span>
<img src="https://i.loli.net/2019/12/25/x3DwPCTtBpQ4h5v.jpg" alt="支持向量机对螺旋数据集分类的决策边界" width="70%" />
<p class="caption">
Figure 2: 支持向量机对螺旋数据集分类的决策边界
</p>
</div>
<pre class="r"><code>library(caret)
library(e1071)
svmc = svm(smsmat, Y)
#saveRDS(svmc, &quot;svmc.rds&quot;)
print(svmc)</code></pre>
<pre><code># 
# Call:
# svm.default(x = smsmat, y = Y)
# 
# 
# Parameters:
#    SVM-Type:  C-classification 
#  SVM-Kernel:  radial 
#        cost:  1 
#       gamma:  0.01960784 
# 
# Number of Support Vectors:  1386</code></pre>
<pre class="r"><code>summary(svmc)</code></pre>
<pre><code># 
# Call:
# svm.default(x = smsmat, y = Y)
# 
# 
# Parameters:
#    SVM-Type:  C-classification 
#  SVM-Kernel:  radial 
#        cost:  1 
#       gamma:  0.01960784 
# 
# Number of Support Vectors:  1386
# 
#  ( 855 531 )
# 
# 
# Number of Classes:  2 
# 
# Levels: 
#  ham spam</code></pre>
<pre class="r"><code>pred = predict(svmc,smsmat)
#confusionMatrix(pred,Y,positive =&#39;spam&#39;,mode=&quot;prec_recall&quot;)
conMatrix = confusionMatrix(pred,Y,
                             positive =&#39;spam&#39;,
                             mode=&quot;prec_recall&quot;) 
conMatrix[[&quot;table&quot;]]</code></pre>
<pre><code>#           Reference
# Prediction  ham spam
#       ham  4757  124
#       spam   68  623</code></pre>
<pre class="r"><code># klaR包也能够实现NaiveBayes.
nb = naiveBayes(smsmat, Y) # 得到模型

#setwd(&#39;F:/Mysite/Mysite/static/archives/Rbasic&#39;)
#保留模型对象
#saveRDS(nb, &quot;naiveBayes.rds&quot;)
#readRDS(&quot;naiveBayes.rds&quot;)
#save(nb,&quot;naiveBayes.RData&quot;)
#load(&quot;naiveBayes.RData&quot;)

pred1 = predict(nb,smsmat)

conMatrix1 = confusionMatrix(pred1,Y,
                              positive =&#39;spam&#39;,
                              mode=&quot;prec_recall&quot;) 
#混淆矩阵
conMatrix1[[&quot;table&quot;]]</code></pre>
<pre><code>#           Reference
# Prediction  ham spam
#       ham  1991   48
#       spam 2834  699</code></pre>
<pre class="r"><code>#混淆矩阵
prop.table(conMatrix1[[&quot;table&quot;]],1)</code></pre>
<pre><code>#           Reference
# Prediction        ham       spam
#       ham  0.97645905 0.02354095
#       spam 0.80215115 0.19784885</code></pre>
<p>限于精力，我就不调参了。<br />
支持向量机算法的准确率为0.97，平衡准确率为0.91。</p>
<p>朴素贝叶斯算法的准确率为0.48，平衡准确率为0.67。</p>
<p>编写一个对混淆矩阵进行可视化的函数<code>plot_table</code>。这个函数其实就是对<code>ggplot2</code>进行了一个简单封装。如果你经常浏览Kaggle的Kernels，你会发现很多人使用这种矩阵图：</p>
<pre class="r"><code>plot_table = function(x,xlab=&#39;Predicted label&#39;,
                       ylab=&#39;True label&#39;,
                       normalize = F){
  if(normalize){
    x = round(prop.table(x,1), 2)
    mar = as.data.frame(x)
  }
  else{
    mar = as.data.frame(x)
  }
  ggplot2::ggplot(mar,aes(mar[,2],mar[,1])) +
    geom_tile(aes(fill=Freq),color=&#39;black&#39;) +
    scale_fill_gradientn(colours = c(&#39;gray98&#39;,
                                     &#39;steelblue1&#39;,
                                     &#39;midnightblue&#39;))+
    geom_label(aes(label = Freq)) +
     labs(fill=&#39;&#39;,x=xlab,y=ylab) +
     ylim(rev(levels(mar[,2])))+
     scale_y_discrete(expand=c(0,0))+
     scale_x_discrete(expand=c(0,0))
}

class(conMatrix1[[&quot;table&quot;]])</code></pre>
<pre><code># [1] &quot;table&quot;</code></pre>
<pre class="r"><code>plot_table(conMatrix1[[&quot;table&quot;]],&#39;Reference&#39;,&#39;Prediction&#39;)+
  theme_bw()</code></pre>
<p><img src="/post/SMS_spam_files/figure-html/unnamed-chunk-11-1.png" width="90%" style="display: block; margin: auto;" /></p>
<pre class="r"><code>plot_table(conMatrix1[[&quot;table&quot;]])+
  theme_bw()</code></pre>
<p><img src="/post/SMS_spam_files/figure-html/unnamed-chunk-11-2.png" width="90%" style="display: block; margin: auto;" /></p>
<pre class="r"><code>plot_table(conMatrix1[[&quot;table&quot;]],&#39;Reference&#39;,&#39;Prediction&#39;,normalize=T)+
  theme_bw()</code></pre>
<p><img src="/post/SMS_spam_files/figure-html/unnamed-chunk-11-3.png" width="90%" style="display: block; margin: auto;" /></p>
<p>抛开准确率问题不谈，这里有另一个问题，为了避免不必要的损失，大部分人更希望过滤系统尽可能不要把有用的信息删掉。也就是说：</p>
<blockquote>
<p>宁可放过一千也不要错杀一个。</p>
</blockquote>
<p>所以，对于这个任务来说，算法的精确率越高越好，召回率(或者说查全率)越低越好。根据混淆矩阵，SVM的召回率为0.83，朴素贝叶斯的召回率为0.94。SVM的精确率为0.9，朴素贝叶斯的精确率为0.2。从混淆矩阵中我们也能看出，朴素贝叶斯算法将更多普通短信归类于垃圾短信了。因此SVM显然是更佳的模型。</p>
</div>
<div id="应用" class="section level1">
<h1>应用</h1>
<p>下面我们用自己输入的短信文本放入朴素贝叶斯模型进行评价。同样，我们编写若干函数用于进行新数据的判别。其中，<code>convert_dtm</code>用于将新的字符串转换为DTM。注意：这个函数最重要的功能是使<strong>新DTM的列不超出训练集</strong>。众所周知，训练集和测试集的列必须一一对应。否则某些模型将会无法计算。
<code>test_result</code>用于得到新数据的预测结果。输入短信字符串，输出垃圾/非垃圾短信的判别结果：</p>
<pre class="r"><code>#2个新的短信字符串
new = &#39;please go home at 4 o clock bro&#39; #非垃圾短信

new2 = &#39;We are trying to call you.Please call our customer service representative on FREEPHONE.Claim code S89. Valid 12hrs only&#39; # 垃圾短信

#对于新数据集。判断DTM的每一列是否在训练集中出现。
#出现保留，没出现剔除，补充空列。
convert_dtm = function(string){ # 得到新数据的DTM
test_dtm = VCorpus(VectorSource(string)) %&gt;% 
  DocumentTermMatrix(., control = list(tolower = T,
                                      removeNumbers = T,
                                      stopwords = T,
                                      removePunctuation = T,
                                      stemming = T)) %&gt;% 
  as.matrix()

smmat = smsmat[1,]  # smsmat 为训练集DTM,提取第一行
smmat = as.data.frame(smmat) # 将matrix转化为data.frame
smmat[,1] = 0 # 将此列所有值设为0
smmat = t(smmat) # 转置
sp = colnames(smmat) %in% colnames(test_dtm) # 判断新数据集在训练集中出现的列
sp2 = colnames(test_dtm) %in% colnames(smmat)
smmat[,sp] = test_dtm[,sp2]  # 提取在训练集中出现的列，将对应的值重编码为频率
return(smmat)
}


test_result = function(model,string){ # 得到新数据的预测结果
  ms_corpus = VCorpus(VectorSource(string))
test_dtm = DocumentTermMatrix(ms_corpus, control =
                                 list(tolower = T,
                                      removeNumbers = T,
                                      stopwords = T,
                                      removePunctuation = T,
                                      stemming = T))
test_dtm = as.matrix(test_dtm)

smmat = smsmat[1,] 
smmat = as.data.frame(smmat) 
smmat[,1] = 0 
smmat = t(smmat)
sp = colnames(smmat) %in% colnames(test_dtm)
sp2 = colnames(test_dtm) %in% colnames(smmat)
smmat[,sp] = test_dtm[,sp2]
result = predict(model,smmat)
result = as.character(result)
return(result)
}

#可以看出&#39;call&#39;的词频为2
convert_dtm(new2)</code></pre>
<pre><code>#       ask back call can come day dont free get give good got home hope
# smmat   0    0    2   0    0   0    0    0   0    0    0   0    0    0
#       just know later like lor love ltgt make meet mobil need new now one
# smmat    0    0     0    0   0    0    0    0    0     0    0   0   0   0
#       phone pleas repli say see send sorri still stop take tell text think
# smmat     0     0     0   0   0    0     0     0    0    0    0    0     0
#       time today tri txt want week well will work you
# smmat    0     0   1   0    0    0    0    0    0   0</code></pre>
<pre class="r"><code># 现在进行结果预测
test_result(nb,new)</code></pre>
<pre><code># [1] &quot;ham&quot;</code></pre>
<pre class="r"><code>test_result(nb,new2)</code></pre>
<pre><code># [1] &quot;spam&quot;</code></pre>
<pre class="r"><code>test_result(svmc,new)</code></pre>
<pre><code># [1] &quot;ham&quot;</code></pre>
<pre class="r"><code>test_result(svmc,new2)</code></pre>
<pre><code># [1] &quot;spam&quot;</code></pre>
<p>经过检验，支持向量机不能支持新数据的预测。如果新的测试集的变量超出了训练集的变量，就无法运行。而朴素贝叶斯可以(我没弄清楚为什么)。不过无所谓，我们的<code>test_result</code>函数完美解决了这个问题。理论上我们可以训练任何一种模型然后测试新数据。</p>
<p>另外，为了更好地分享短信过滤程序，我将训练好的新模型保存下来并编写成Shiny App。使得用户输入任意短信文本就能在用户友好的图形界面的得到判定结果。用户可以点击<a href="https://github.com/ECSTA7Y/txtnb">这里</a>查看Shiny App的源代码。本来我将这个App部署到了<a href="https://xiaosong.shinyapps.io/txtnb/">shinyapps.io</a>这个网站上，但它免费版的服务非常不靠谱，几乎是点进去就崩溃。所以想使用它的话，可以在本地的R中输入代码下载并运行这个程序：</p>
<pre class="r"><code>library(shiny)
runGitHub( &quot;txtnb&quot;, &quot;songxxiao&quot;)</code></pre>
<p><img src="https://i.loli.net/2019/12/25/lQ3mIj5iDNFzUMx.gif" width="70%" style="display: block; margin: auto;" /></p>
</div>
