geom_polygon(colour="brown",size=0.2) +
scale_fill_gradientn(colours = c("yellow", "red"),na.value = "white",
breaks = c(10,20,30,40),limits=c(0,43), guide = "legend") +
coord_map("polyconic") +
facet_wrap(~variable) +
theme(
panel.grid = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
legend.position = "none",
plot.title = element_text(hjust = 0.5,vjust=0.9, size=11),
legend.title = element_text(size=0),
plot.margin = unit(c(0.001,0.001,0.001,0.001), "cm"))
library(reshape2)
long<- melt(china_data, id=c("long", "lat","group"))
library(ggplot2)
ggplot(china_data, aes(x = long, y = lat, group = group,fill= value)) +
geom_polygon(colour="brown",size=0.2) +
scale_fill_gradientn(colours = c("yellow", "red"),na.value = "white",
breaks = c(10,20,30,40),limits=c(0,43), guide = "legend") +
coord_map("polyconic") +
facet_wrap(~variable) +
theme(
panel.grid = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
legend.position = "none",
plot.title = element_text(hjust = 0.5,vjust=0.9, size=11),
legend.title = element_text(size=0),
plot.margin = unit(c(0.001,0.001,0.001,0.001), "cm"))
library(reshape2)
long<- melt(china_data, id=c("long", "lat","group"))
library(ggplot2)
ggplot(long, aes(x = long, y = lat, group = group,fill= value)) +
geom_polygon(colour="brown",size=0.2) +
scale_fill_gradientn(colours = c("yellow", "red"),na.value = "white",
breaks = c(10,20,30,40),limits=c(0,43), guide = "legend") +
coord_map("polyconic") +
facet_wrap(~variable) +
theme(
panel.grid = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
legend.position = "none",
plot.title = element_text(hjust = 0.5,vjust=0.9, size=11),
legend.title = element_text(size=0),
plot.margin = unit(c(0.001,0.001,0.001,0.001), "cm"))
library(reshape2)
long<- melt(china_data, id=c("long", "lat","group"))
library(ggplot2)
ggplot(long, aes(x = long, y = lat, group = group,fill= value)) +
geom_polygon(colour="brown",size=0.2) +
scale_fill_gradientn(colours = c("yellow", "red"),na.value = "white",
breaks = c(10,20,30,40),limits=c(0,43), guide = "legend") +
coord_map("polyconic") +
facet_wrap(~variable,nrow = 3) +
theme(
panel.grid = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
legend.position = "none",
plot.title = element_text(hjust = 0.5,vjust=0.9, size=11),
legend.title = element_text(size=0),
plot.margin = unit(c(0.001,0.001,0.001,0.001), "cm"))
mod1 <- lm(y ~ x data = moto)
set.seed(711)
x = seq(0, 4, length = 100)
y = -x + jitter(rep(1:5, each = 20), 2)
z = rep(1:5, each = 20)
z <- as.factor(z)
moto <- data.frame(x,y,z)
ggplot(moto, aes(x, y)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
ggplot(moto, aes(x, y)) +
geom_point(aes(color = z)) +
facet_wrap(~z, nrow = 2) +
geom_smooth(method='lm',se=F)
mod1 <- lm(y ~ x data = moto)
mod1 <- lm(y ~ x,data = moto)
grid <- moto %>%
data_grid(x) %>%
gather_predictions(mod1)
library
modelr
library(modelr)
grid <- moto %>%
data_grid(x) %>%
gather_predictions(mod1)
View(grid)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_line(data = grid, aes(y = y))
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_line(data = grid, aes(y = y,x=x))
ggplot(moto, aes(x, y,group=z,color = z)) +
geom_point(size=3) +
geom_line(data = grid, aes(y = y,x=x))
library(modelr)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
mod1 <- lm(y ~ x,data = moto)
grid <- moto %>%
data_grid(x) %>%
gather_predictions(mod1)
head(grid)
ggplot(moto, aes(x, y,group=z,color = z)) +
geom_point(size=3) +
geom_line(data = grid, aes(y = y,x=x))
library(modelr)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
mod1 <- lm(y ~ x + z,data = moto)
grid <- moto %>%
data_grid(x) %>%
gather_predictions(mod1)
head(grid)
ggplot(moto, aes(x, y,group=z,color = z)) +
geom_point(size=3) +
geom_line(data = grid, aes(y = y,x=x))
library(modelr)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
mod1 <- lm(y ~ x + z,data = moto)
grid <- moto %>%
data_grid(x,z) %>%
gather_predictions(mod1)
head(grid)
ggplot(moto, aes(x, y,group=z,color = z)) +
geom_point(size=3) +
geom_line(data = grid, aes(y = y,x=x))
library(modelr)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
mod1 <- lm(y ~ x + z,data = moto)
grid <- moto %>%
data_grid(x,y) %>%
gather_predictions(mod1)
library(modelr)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
mod1 <- lm(y ~ x + z,data = moto)
grid <- moto %>%
data_grid(x) %>%
gather_predictions(mod1)
head(grid)
ggplot(moto, aes(x, y,group=z,color = z)) +
geom_point(size=3) +
geom_line(data = grid, aes(y = y,x=x))
library(modelr)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
mod1 <- lm(y ~ x + z,data = moto)
grid <- moto %>%
data_grid(x,z) %>%
gather_predictions(mod1)
head(grid)
ggplot(moto, aes(x, y,group=z,color = z)) +
geom_point(size=3) +
geom_line(data = grid, aes(y = prde,x=x))
library(modelr)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
mod1 <- lm(y ~ x + z,data = moto)
grid <- moto %>%
data_grid(x,z) %>%
gather_predictions(mod1)
head(grid)
ggplot(moto, aes(x, y,group=z,color = z)) +
geom_point(size=3) +
geom_line(data = grid, aes(y = pred,x=x))
library(modelr)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
mod1 <- lm(y ~ x + z,data = moto)
grid <- moto %>%
data_grid(x,z) %>%
gather_predictions(mod1)
head(grid)
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_line(data = grid, aes(y = pred,x=x))
#不同组拟合不同的模型
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_smooth(method='lm',se=F)
library(modelr)
mod1 <- lm(y ~ x + z,data = moto)
grid <- moto %>%
data_grid(x,z) %>%
gather_predictions(mod1)
knitr::kable(head(grid),caption="数据概要",align='c')
#不同组拟合同一个模型，控制组z
ggplot(moto, aes(x, y,group=z)) +
geom_point(aes(color = z),size=3) +
geom_line(data = grid, aes(y = pred,x=x),size=0.7,color='blue') +
ylim(0.5,2)
library(rgdal)
bottom  <- readOGR(dsn = "E:/R_codes/maps/CHN_adm/CHN_adm2.shp",stringsAsFactors=FALSE)
install.packages('rgdal')
library(rgdal)
bottom  <- readOGR(dsn = "E:/R_codes/maps/CHN_adm/CHN_adm2.shp",stringsAsFactors=FALSE)
library(ggplot2)
bottomdata <- fortify(bottom)
x <- bottom@data
xs <- data.frame(x,id=seq(0:344)-1)
library(plyr)
china_map <- join(bottomdata, xs, type = "full")
table(china_map$NAME_2)
library(readxl)
jin <- read_excel("E:/R_codes/maps/pointmap/citydis.xlsx")
china_map <- join(china_map, jin, type = "full")
table(china_map$freq)
point <- china_map
point <- na.omit(point)
midpos <- function(x) mean(range(x,na.rm=TRUE)) #???????????????????????????
centres <- ddply(china_map,.(NAME_2),colwise(midpos,.(long,lat)))
center <- join(centres, jin, type = "full")
center  <- na.omit(center)
library(ggplot2)
ggplot(china_map,aes(x=long,y=lat)) +
geom_polygon(aes(group = group),fill="white",color="black",size=0.1) + #?????????,NA???????????? +
geom_point(mapping = aes(x=long, y=lat, size = freq),data = center, colour = "steelblue") +
coord_map("polyconic") +
theme(
panel.grid = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
legend.position = c(0.85,0.5)
)
ggplot(china_map,aes(x=long,y=lat)) +
geom_polygon(aes(group = group),fill="white",color="black",size=0.1) + #?????????,NA???????????? +
geom_point(mapping = aes(x=long, y=lat, size = freq),data = center, colour = "steelblue") +
coord_map("polyconic") +
theme(
panel.grid = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
legend.position = c(0.85,0.5)
)
rm(list=ls())
setwd("C:/Users/lenovo/Desktop/geography/jin")
#library(maptools)
#bottom <- readShapePoly("E:/R codes/maps/CHN_adm/CHN_adm2.shp")
library(rgdal)
bottom  <- readOGR(dsn = "E:/R_codes/maps/CHN_adm/CHN_adm2.shp",stringsAsFactors=FALSE)
library(ggplot2)
bottomdata <- fortify(bottom)
x <- bottom@data
xs <- data.frame(x,id=seq(0:344)-1)
library(plyr)
china_map <- join(bottomdata, xs, type = "full")
table(china_map$NAME_2)
library(readxl)
jin <- read_excel("E:/R_codes/maps/pointmap/citydis.xlsx")
china_map <- join(china_map, jin, type = "full")
table(china_map$freq)
point <- china_map
point <- na.omit(point)
midpos <- function(x) mean(range(x,na.rm=TRUE)) #???????????????????????????
centres <- ddply(china_map,.(NAME_2),colwise(midpos,.(long,lat)))
center <- join(centres, jin, type = "full")
center  <- na.omit(center)
library(ggplot2)
ggplot(china_map,aes(x=long,y=lat)) +
geom_polygon(aes(group = group),fill="white",color="black",size=0.1) + #?????????,NA???????????? +
geom_point(mapping = aes(x=long, y=lat, size = freq),data = center, colour = "steelblue") +
coord_map("polyconic") +
theme(
panel.grid = element_blank(),
panel.background = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.title = element_blank(),
legend.position = c(0.85,0.5)
)
mar<-c(652,1537,598,242,36,46,38,21,218,327,106,67)
caff.marital<-matrix(mar,nrow=3,byrow=T)
caff.marital
?matrix
?cbind
h <- c(1:24)
h
Z <- array(h, dim=c(3,4,2))
Z
?apply
?lapply
movies <- c("SPYDERMAN","BATMAN","VERTIGO","CHINATOWN")
movies_lower <-lapply(movies, tolower)
movies_lower
?unlist
x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
# compute the list mean for each list element
lapply(x, mean)
# median and quartiles for each list element
lapply(x, quantile, probs = 1:3/4)
sapply(x, quantile)
i39 <- sapply(3:9, seq) # list of vectors
sapply(i39, fivenum)
vapply(i39, fivenum,
c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
x
class(sapply(x, quantile))
sapply(x, quantile,simplify=T)
sapply(x, quantile)
pply(x, quantile, probs = 1:3/4,simplify=T)
lapply(x, quantile, probs = 1:3/4,simplify=T)
lapply(x, quantile, probs = 1:3/4)
sapply(x, quantile,simplify="array")
class(sapply(x, quantile,simplify="array"))
sapply(x, quantile)
mar<-c(652,1537,598,242,36,46,38,21,218,327,106,67)
caff.marital<-matrix(mar,nrow=3,byrow=T) #byrow=T通过行来填充
caff.marital
#nrow和ncol中的一个被明确给出，则R会计算相应的另一个，从而使得矩阵中的数值与输入的值数目相匹配
x <- array(1:20, dim=c(4,5))
x
h <- c(1:24)
Z <- array(h, dim=c(3,4,2)) #创建3X4X2的数组
Z
z[, ,1]
mar<-c(652,1537,598,242,36,46,38,21,218,327,106,67)
caff.marital<-matrix(mar,nrow=3,byrow=T) #byrow=T通过行来填充
caff.marital
#nrow和ncol中的一个被明确给出，则R会计算相应的另一个，从而使得矩阵中的数值与输入的值数目相匹配
x <- array(1:20, dim=c(4,5))
x
h <- c(1:24)
Z <- array(h, dim=c(3,4,2)) #创建3X4X2的数组
Z
z[, ,1]
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)
column.names <- c("COL1","COL2","COL3")
row.names <- c("ROW1","ROW2","ROW3")
matrix.names <- c("Matrix1","Matrix2")
# Take these vectors as input to the array.
result <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,
column.names, matrix.names))
# Print the third row of the second matrix of the array.
print(result[3,,2])
# Print the element in the 1st row and 3rd column of the 1st matrix.
print(result[1,3,1])
# Print the 2nd Matrix.
print(result[,,2])
iris
as_tibble(iris)
library(tidyverse)
as_tibble(iris)
?data.table
??data.table
install.packages("data.table")
library(data.table)
install.packages("reticulate")
library(reticulate)
py_available()
py_available()
py_available()
os <- import(“os”)
os <- import('os')
os$getcwd()
os$listdir()
conda_create(“r-reticulate”)
conda_create('r-reticulate')
conda_install('r-reticulate','numpy')
repl_python()
from sklearn import datasets
from sklearn.linear_model import LogisticRegression
# 加载数据库
iris = datasets.load_iris()
# 建立logit模型
model = LogisticRegression()
model.fit(iris.data, iris.target)
# 进行预测
actual = iris.target
predicted = model.predict(iris.data)
#模型性能对比矩阵
print(metrics.classification_report(actual, predicted))
print(metrics.confusion_matrix(actual, predicted))
repl_python()
def bubble(List):
for j in range(len(List)-1,0,-1):
print(List)
for i in range(0,j):
if List[i]>List[i+1]:
List[i],List[i+1] = List[i+1],List[i]
return List
testlist = [49,38,65,97,76,13,27,49]
print('结果：',bubble(testlist))
#选择排序算法：程序填空
def selection_sort(L):
N = len(L) #提取列表长度N
exchange_count = 0
for i in range(0, N-1): #从0开始循环
min_index = i #排序序列的末尾位置
for j in range(i+1,N): #嵌套循环
if L[min_index] > L[j]: #第一次循环L[0]>L[1]
min_index = j #第一次循环min_index=1  j是二者最小值的列表索引。
#min_index永远等于最小值索引
#以下是移动程序
if min_index!= i: #如果索引交换了
L[min_index],L[i] = L[i],L[min_index] #交换值
exchange_count += 1
print('iteration#{}:{}'.format(i,L))
print('Total {} swappings'.format(exchange_count))
return L
testlist = [49,38,49,97,76,13,27,65]
selection_sort(testlist)
import pandas as pd
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
'year': [2000, 2001, 2002, 2001, 2002, 2003],
'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]} #字典
frame = pd.DataFrame(data)
frame
library(reticulate)
repl_python()
import pandas as pd
import numpy as np
data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
'year': [2000, 2001, 2002, 2001, 2002, 2003],
'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]} #字典
frame = pd.DataFrame(data)
frame
np.where(frame['year']>2000,frame.drop(),frame)
frame
conda_install("numpy")
conda_install("numpy")
library(reticulate)
conda_install("numpy")
library(reticulate)
conda_create(“r-reticulate”)
library(reticulate)
conda_create("r-reticulate")
repl_python()
# 加载包
from sklearn import datasets
from sklearn.linear_model import LogisticRegression
# 加载数据库
iris = datasets.load_iris()
# 建立logit模型
model = LogisticRegression()
model.fit(iris.data, iris.target)
# 进行预测
actual = iris.target
predicted = model.predict(iris.data)
#模型性能对比矩阵
print(metrics.classification_report(actual, predicted))
print(metrics.confusion_matrix(actual, predicted))
library(reticulate)
repl_python()
# 加载包
from sklearn import datasets
from sklearn.linear_model import LogisticRegression
# 加载数据库
iris = datasets.load_iris()
# 建立logit模型
model = LogisticRegression()
model.fit(iris.data, iris.target)
# 进行预测
actual = iris.target
predicted = model.predict(iris.data)
#模型性能对比矩阵
print(metrics.classification_report(actual, predicted))
print(metrics.confusion_matrix(actual, predicted))
py_module_available(“pandas”)
py_module_available('pandas')
repl_python()
library(reticulate)
conda_create(“r-reticulate”)
conda_create("r-reticulate")
conda_install("r-reticulate","numpy")
　repl_python()
from sklearn import datasets
from sklearn.linear_model import LogisticRegression
iris = datasets.load_iris()
iris.head()
model = LogisticRegression()
model.fit(iris.data, iris.target)
actual = iris.target
　　predicted = model.predict(iris.data)
print(metrics.classification_report(actual, predicted))
　　print(metrics.confusion_matrix(actual, predicted))
py_module_available(“pandas”)
py_module_available('pandas')
exit
py_module_available('pandas')
py_module_available('matplotlib')
py_module_available('scipy')
devtools::install_github("rstudio/reticulate")
setwd('F:\\Mysite\\Mysite')
blogdown:::serve_site()
