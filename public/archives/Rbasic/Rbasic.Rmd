---
title: "R 基础操作" 
subtitle: ' '
author: '宋骁'
date: ' '
output:
  bookdown::html_document2:
    toc: true
    theme: united
slug: basicr
## bookdown themes:https://bookdown.org/yihui/bookdown/theming.html
---

本文收集了我在学习R过程中觉得重要的知识点。

# 基本对象

模式强制转换：字符串：`as.character()`,整数：`as.integer()`,向量：`as.vector()`, 数据框：`as.data.frame()`

## 数组和矩阵

```{r,include=F}
knitr::opts_chunk$set(comment=NA,error=T,message = F,warning = F,fig.align='center',out.width ='100%')
```

```{r}
library(dplyr)
library(ggplot2)
library(magrittr)
library(dplyr)
library(titanic)

mar<-c(652,1537,598,242,36,46,38,21,218,327,106,67)
caff.marital<-matrix(mar,nrow=3,byrow=T) #byrow=T通过行来填充
caff.marital
#nrow和ncol中的一个被明确给出，则R会计算相应的另一个，从而使得矩阵中的数值与输入的值数目相匹配
x <- array(1:20, dim=c(4,5))  
x

h <- c(1:24)
Z <- array(h, dim=c(3,4,2)) #创建3X4X2的数组
Z
Z[,,2]#索引
vec <- as.vector(Z)
vec

# 数组命名
vector1 <- c(5,9,3)
vector2 <- c(10,11,12,13,14,15)
column.names <- c("COL1","COL2","COL3")
row.names <- c("ROW1","ROW2","ROW3")
matrix.names <- c("Matrix1","Matrix2")

result <- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,
   matrix.names))
result
result[,,'Matrix2'] #索引
```

## 列表

+ 列表（list）是一个以对象的有序集合构成的对象。列表中包含的对象又称为它的分量（components）。
分量可以是不同的模式或类型，如一个列表可以同时包括数值向量，逻辑向量，矩阵，复向量，字符数组，函数等等。

# 循环
`for`循环
```{r}
pp <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers")
for(i in seq_along(pp)) print(pp[i])
```


# `apply()`族函数

[Tutorial on the R Apply Family](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family?utm_source=adwords_ppc&utm_campaignid=1565261270&utm_adgroupid=67750485268&utm_device=c&utm_keyword=&utm_matchtype=b&utm_network=g&utm_adpostion=1t1&utm_creative=332661264365&utm_targetid=aud-392016246653:dsa-473406586995&utm_loc_interest_ms=&utm_loc_physical_ms=9032008&gclid=CjwKCAjw6vvoBRBtEiwAZq-T1VINBuWR5b5Pe3QeGmfaBBSQ_57nvMN6p7H1AVs3iBpQXgEx480XuxoC_0UQAvD_BwE)

包括`sapply()`, `lapply()`, 和 `tapply()`

`lapply()`默认返回值是列表

`aggregate()`类似于`dplyr::group_by`

```{r}
sapply(iris, class)
```





# `dplyr`处理缺失值


```{r}
stocks <- tibble(
year = c(2015, NA, 2015, 2015, NA, 2016, 2016),
qtr = c( 1, 2, NA, NA, 2, NA, 4),
return = c(1.88, 0.44, 0.35, 0.66, 0.92, 0.17, 3.40)
)
knitr::kable(stocks,caption = '数据概要')
```

缺失值重编码成其他值：

+ 任务，将`qtr`等于`NA`的行的`year`变量重编码为`9999`

+ `dplyr::recode`无法给出条件

```{r}
stocks %>% mutate(year= ifelse(is.na(qtr),9999,year))

stocks %>% mutate(year=case_when(
  is.na(qtr) ~ 9999,
  is.na(qtr)==F ~ year,
))

stocks %>% mutate(year=replace(year,is.na(qtr),9999))
```

其他值重编码成缺失值：

+ 

+ 使用`na_if`。但是无法给出条件。

```{r}
stocks %>% mutate(return=ifelse(year==2016,NA,return))

stocks %>% mutate(return=replace(return,year==2016,NA))

stocks %>% mutate(return=na_if(return,year==2016))

stocks %>% mutate(year=na_if(year,2016))

stocks %>% mutate(return=na_if(year==2016,return))

```

# 数据合并

+ `cbind()`把矩阵横向合并成一个大矩阵（列方式），而`rbind()`是纵向合并（行方式）。

+ `dplyr`的`join`方法

```{r,cache=T}

myData <- data.frame(
    nation=rep(c('USA','Japan','Libya'),3),
    subregion=rep(c('north','south','middle'),each=3),
    Awesomeness=rnorm(9)
    )
myData

countryData <- data.frame(
    nation=c('USA','Japan','Libya','Belarus'),
    NumberOfSquid=c(rpois(4,10))
    )
countryData

myData %>% full_join(countryData,copy=T)
myData %>% left_join(countryData,copy=T)

library(plyr)
join(myData, countryData, by='nation', type='left', match='all')

```

# 使用`devtools`本地安装R包

以`REmap`包为例,从[github](https://github.com/)上下载压缩包后，使用`install_local`安装。

```{r,eval=F}
library(devtools)
install_github('lchiffon/REmap') #可以试试，但基本不好使
install_local("C:/Users/lenovo/Desktop/REmap-master.zip") #设置正确的本地路径
```

# [`magrittr`](https://magrittr.tidyverse.org/)管道操作符

[张丹的文章](https://mp.weixin.qq.com/s/wD2tK04qGJ8Qvb-sD0Nhcg)

`%T>%`

`%$%`

```{r }
rnorm(100) %>%
matrix(ncol = 2) %T>%
plot() %>%
str()

myData %$%
  table(nation,subregion)

mar <- 
myData %$%
  table(nation,subregion) %>% 
  as.data.frame()

```

# 函数

+ 自己编写一个绘制交互表图形的函数`plot_table`。其中`x`为行向量，`y`为列向量，`xlab`为行标签，`ylab`为列标签。

```{r,out.width='80%'}
plot_table <- function(x,y,xlab=x,ylab=y){
  mar <- as.data.frame(table(x,y))
  ggplot2::ggplot(mar,aes(mar[,1],mar[,2])) +
  geom_tile(aes(fill=Freq),color='black') +
  scale_fill_gradient(low='white',high = 'steel blue')+
  geom_text(aes(label = Freq)) + labs(fill="频数",x=xlab,y=ylab)
}

data("titanic_train")
titanic <- titanic_train %>% 
  as.data.frame()

titanic %$%
plot_table(Sex,Survived)

titanic %$%
plot_table(Sex,Survived,"性别","是否生存")


```


```{r}
scattplot <- function(x,y){
  plot(x,y)
  return(x+y)
}
x <- rnorm(10)
y <- rnorm(10,2,3)
scattplot(x,y)
```

# 导出Stata文件

```{r,eval=F}
library(foreign)
write.dta(`2011`,'C:/Users/201108.dta')
```

# 样条

```{r}
library(splines)
n = 100
x = rnorm(n)
## Some non-linear function of x
p = plogis(2 * cos(5 * x) - 1)
y = rbinom(n, 1, p)

model = glm(y ~ bs(x), family = binomial())
pred = predict(model, bs(x))
plot(x, pred)
```


```{r}
require(stats); require(graphics)
bs(women$height, df = 5)
summary(fm1 <- lm(weight ~ bs(height, df = 5), data = women))

## example of safe prediction
plot(women, xlab = "Height (in)", ylab = "Weight (lb)")
ht <- seq(57, 73, length.out = 200)
lines(ht, predict(fm1, data.frame(height = ht)))
```

# 广义可加模型 

+ Generalized Additive Models(GAM)

$$y = {\beta _0} + {f_1}({x_1}) + {f_2}({x_2}) +  \cdot  \cdot  \cdot  + {f_m}({x_m})$$
$f(x)$可以是样条、Lowess(局部多项式)等平滑方法。它和多元线性回归类似，但将$\beta x$替换为平滑函数。GAM使用backfitting algorithm使损失函数最小。

```{r}
library(mgcv)
set.seed(2) ## simulate some data... 
dat <- gamSim(1,n=400,dist="normal",scale=2)
b <- gam(y~s(x0)+s(x1)+s(x2)+s(x3),data=dat)
summary(b)
plot(b,pages=1,residuals=TRUE)  ## show partial residuals
plot(b,pages=1,seWithMean=TRUE) ## `with intercept' CIs
## run some basic model checks, including checking
## smoothing basis dimensions...
gam.check(b)
```
```{r}
require(mgcv)
require(nlme)
b0 <- lme(travel~1,data=Rail,~1|Rail,method="REML") 

b <- gam(travel~s(Rail,bs="re"),data=Rail,method="REML")

intervals(b0)
gam.vcomp(b)
anova(b)
plot(b)
```

# [`REmap`](https://github.com/Lchiffon/REmap)动态地图

```{r,eval=F}
library(devtools)
install_local("E:/R_codes/maps/REmap-master.zip") 
library(REmap)
set.seed(125)
out = remap(demoC,title = "REmap",subtitle ="theme:Dark")
out
summary(out)

origin<-c("上海","苏州","无锡","常州","南京","蚌埠","徐州","郑州","洛阳","西安","宝鸡","天水","兰州","嘉峪关","哈密","鄯善","吐鲁番")
destination<-c("苏州","无锡","常州","南京","蚌埠","徐州","郑州","洛阳","西安","宝鸡","天水","兰州","嘉峪关","哈密","鄯善","吐鲁番","乌鲁木齐")
#将上面这两列数据存储在一个数据框里面
df <- data.frame(origin,destination)
out <- remap(df ,title = '回家路线',
              subtitle= '2019.1.24')
out
```





```{r}
## see also examples in ?gam.models (e.g. 'by' variables, 
## random effects and tricks for large binary datasets)

library(mgcv)
set.seed(2) ## simulate some data... 
dat <- gamSim(1,n=400,dist="normal",scale=2)
b <- gam(y~s(x0)+s(x1)+s(x2)+s(x3),data=dat)
summary(b)
plot(b,pages=1,residuals=TRUE)  ## show partial residuals
plot(b,pages=1,seWithMean=TRUE) ## `with intercept' CIs
## run some basic model checks, including checking
## smoothing basis dimensions...
gam.check(b)

## same fit in two parts .....
G <- gam(y~s(x0)+s(x1)+s(x2)+s(x3),fit=FALSE,data=dat)
b <- gam(G=G)
print(b)

## 2 part fit enabling manipulation of smoothing parameters...
G <- gam(y~s(x0)+s(x1)+s(x2)+s(x3),fit=FALSE,data=dat,sp=b$sp)
G$lsp0 <- log(b$sp*10) ## provide log of required sp vec
gam(G=G) ## it's smoother

## change the smoothness selection method to REML
b0 <- gam(y~s(x0)+s(x1)+s(x2)+s(x3),data=dat,method="REML")
## use alternative plotting scheme, and way intervals include
## smoothing parameter uncertainty...
plot(b0,pages=1,scheme=1,unconditional=TRUE) 

## Would a smooth interaction of x0 and x1 be better?
## Use tensor product smooth of x0 and x1, basis 
## dimension 49 (see ?te for details, also ?t2).
bt <- gam(y~te(x0,x1,k=7)+s(x2)+s(x3),data=dat,
          method="REML")
plot(bt,pages=1) 
plot(bt,pages=1,scheme=2) ## alternative visualization
AIC(b0,bt) ## interaction worse than additive

## Alternative: test for interaction with a smooth ANOVA 
## decomposition (this time between x2 and x1)
bt <- gam(y~s(x0)+s(x1)+s(x2)+s(x3)+ti(x1,x2,k=6),
            data=dat,method="REML")
summary(bt)

## If it is believed that x0 and x1 are naturally on 
## the same scale, and should be treated isotropically 
## then could try...
bs <- gam(y~s(x0,x1,k=40)+s(x2)+s(x3),data=dat,
          method="REML")
plot(bs,pages=1)
AIC(b0,bt,bs) ## additive still better. 

## Now do automatic terms selection as well
b1 <- gam(y~s(x0)+s(x1)+s(x2)+s(x3),data=dat,
       method="REML",select=TRUE)
plot(b1,pages=1)


## set the smoothing parameter for the first term, estimate rest ...
bp <- gam(y~s(x0)+s(x1)+s(x2)+s(x3),sp=c(0.01,-1,-1,-1),data=dat)
plot(bp,pages=1,scheme=1)
## alternatively...
bp <- gam(y~s(x0,sp=.01)+s(x1)+s(x2)+s(x3),data=dat)


# set lower bounds on smoothing parameters ....
bp<-gam(y~s(x0)+s(x1)+s(x2)+s(x3),
        min.sp=c(0.001,0.01,0,10),data=dat) 
print(b);print(bp)

# same with REML
bp<-gam(y~s(x0)+s(x1)+s(x2)+s(x3),
        min.sp=c(0.1,0.1,0,10),data=dat,method="REML") 
print(b0);print(bp)


## now a GAM with 3df regression spline term & 2 penalized terms

b0 <- gam(y~s(x0,k=4,fx=TRUE,bs="tp")+s(x1,k=12)+s(x2,k=15),data=dat)
plot(b0,pages=1)


## now simulate poisson data...
set.seed(6)
dat <- gamSim(1,n=2000,dist="poisson",scale=.1)

## use "cr" basis to save time, with 2000 data...
b2<-gam(y~s(x0,bs="cr")+s(x1,bs="cr")+s(x2,bs="cr")+
        s(x3,bs="cr"),family=poisson,data=dat,method="REML")
plot(b2,pages=1)

## drop x3, but initialize sp's from previous fit, to 
## save more time...

b2a<-gam(y~s(x0,bs="cr")+s(x1,bs="cr")+s(x2,bs="cr"),
         family=poisson,data=dat,method="REML",
         in.out=list(sp=b2$sp[1:3],scale=1))
par(mfrow=c(2,2))
plot(b2a)

par(mfrow=c(1,1))
## similar example using GACV...

dat <- gamSim(1,n=400,dist="poisson",scale=.25)

b4<-gam(y~s(x0)+s(x1)+s(x2)+s(x3),family=poisson,
        data=dat,method="GACV.Cp",scale=-1)
plot(b4,pages=1)

## repeat using REML as in Wood 2011...

b5<-gam(y~s(x0)+s(x1)+s(x2)+s(x3),family=poisson,
        data=dat,method="REML")
plot(b5,pages=1)

 
## a binary example (see ?gam.models for large dataset version)...

dat <- gamSim(1,n=400,dist="binary",scale=.33)

lr.fit <- gam(y~s(x0)+s(x1)+s(x2)+s(x3),family=binomial,
              data=dat,method="REML")

## plot model components with truth overlaid in red
op <- par(mfrow=c(2,2))
fn <- c("f0","f1","f2","f3");xn <- c("x0","x1","x2","x3")
for (k in 1:4) {
  plot(lr.fit,residuals=TRUE,select=k)
  ff <- dat[[fn[k]]];xx <- dat[[xn[k]]]
  ind <- sort.int(xx,index.return=TRUE)$ix
  lines(xx[ind],(ff-mean(ff))[ind]*.33,col=2)
}
par(op)
anova(lr.fit)
lr.fit1 <- gam(y~s(x0)+s(x1)+s(x2),family=binomial,
               data=dat,method="REML")
lr.fit2 <- gam(y~s(x1)+s(x2),family=binomial,
               data=dat,method="REML")
AIC(lr.fit,lr.fit1,lr.fit2)

## For a Gamma example, see ?summary.gam...

## For inverse Gaussian, see ?rig

## now 2D smoothing...

eg <- gamSim(2,n=500,scale=.1)
attach(eg)

op <- par(mfrow=c(2,2),mar=c(4,4,1,1))

contour(truth$x,truth$z,truth$f) ## contour truth
b4 <- gam(y~s(x,z),data=data) ## fit model
fit1 <- matrix(predict.gam(b4,pr,se=FALSE),40,40)
contour(truth$x,truth$z,fit1)   ## contour fit
persp(truth$x,truth$z,truth$f)    ## persp truth
vis.gam(b4)                     ## persp fit
detach(eg)
par(op)

##################################################
## largish dataset example with user defined knots
##################################################

par(mfrow=c(2,2))
n <- 5000
eg <- gamSim(2,n=n,scale=.5)
attach(eg)

ind<-sample(1:n,200,replace=FALSE)
b5<-gam(y~s(x,z,k=40),data=data,
        knots=list(x=data$x[ind],z=data$z[ind]))
## various visualizations
vis.gam(b5,theta=30,phi=30)
plot(b5)
plot(b5,scheme=1,theta=50,phi=20)
plot(b5,scheme=2)

par(mfrow=c(1,1))
## and a pure "knot based" spline of the same data
b6<-gam(y~s(x,z,k=64),data=data,knots=list(x= rep((1:8-0.5)/8,8),
        z=rep((1:8-0.5)/8,rep(8,8))))
vis.gam(b6,color="heat",theta=30,phi=30)

## varying the default large dataset behaviour via `xt'
b7 <- gam(y~s(x,z,k=40,xt=list(max.knots=500,seed=2)),data=data)
vis.gam(b7,theta=30,phi=30)
detach(eg)
```

# 最大似然估计

[Fitting a Model by Maximum Likelihood](https://www.r-bloggers.com/fitting-a-model-by-maximum-likelihood/)

[Who knew likelihood functions could be so pretty?](https://www.r-bloggers.com/who-knew-likelihood-functions-could-be-so-pretty/)

```{r,eval=F}
LL <- function(X, theta)
{
  mu <- theta[1]
  sigma2 <- theta[2]
  log.likelihood <- 0
  n <- length(X)
  for (i in 1:length(X))
  {
      log.likelihood <- log.likelihood - (((X[i]-mu)^2)/(2*sigma2)) - log(sqrt(2*pi*sigma2))
  }
  
  return(log.likelihood)
}

#Parameters
Mu <- 100
Sigma2 <- 50

#Sample
N <- 100
set.seed(1)
IQs <- rnorm(N, mean=Mu, sd=sqrt(Sigma2))

#Possible values to test
x <- posMu <- seq(80, 120, length.out=200)
y <- posSig <- seq(20, 60, length.out=200)
#x1 <- sort(x, decreasing=T)


#Produce LLs for plotting
LLlist <- NULL
for (m in 1:length(posMu)){
  LLs <- NULL
  for(s in 1:length(posSig)){
    posTheta <- cbind(posMu[m],posSig[s])
    LLs <- c(LLs, LL(IQs,posTheta)) 
  }
  LLlist <- cbind(LLlist,LLs, deparse.level=0)
}
z <- LLlist

#Find the approximate MLE 
mLL <- which(LLlist == max(LLlist), arr.ind=TRUE)
cbind(posMu[mLL[2]],posSig[mLL[1]],LLlist[mLL])

#Graph the LLs
library(rgl)
open3d()
plot3d(mean(x),mean(y),mean(z), xlab="Mu", ylab="Sigma2", zlab="log L", xlim=c(min(x),max(x)), ylim=c(min(y),max(y)), zlim=c(min(z),max(z)))
surface3d(x, y, z, color=rainbow(length(x)))
```



```{r,eval=F}
library(fitdistrplus)
# (1) loglikelihood or likelihood curve
#

n <- 100
set.seed(1234)
x <- rexp(n)

llcurve(data = x, distr = "exp", plot.arg =  "rate", min.arg = 0, max.arg = 4)

llcurve(data = x, distr = "exp", plot.arg =  "rate", min.arg = 0, max.arg = 4, 
loglik = FALSE)

llcurve(data = x, distr = "exp", plot.arg =  "rate", min.arg = 0, max.arg = 4, 
  main = "log-likelihood for exponential distribution", col = "red")
abline(v = 1, lty = 2)


# (2) loglikelihood surface
# 

x <- rnorm(n, 0, 1)

llsurface(data =x, distr="norm", plot.arg=c("mean", "sd"), 
          min.arg=c(-1, 0.5), max.arg=c(1, 3/2), back.col = FALSE,
          main="log-likelihood for normal distribution")
llsurface(data =x, distr="norm", plot.arg=c("mean", "sd"), 
          min.arg=c(-1, 0.5), max.arg=c(1, 3/2), 
          main="log-likelihood for normal distribution", 
          nlev = 20, pal.col = heat.colors(100),)
points(0, 1, pch="+", col="red")
llsurface(data =x, distr="norm", plot.arg=c("mean", "sd"), 
          min.arg=c(-1, 0.5), max.arg=c(1, 3/2), 
          main="log-likelihood for normal distribution", 
          nlev = 0, back.col = TRUE, pal.col = rainbow(100, s = 0.5, end = 0.8))
points(0, 1, pch="+", col="black")
```


