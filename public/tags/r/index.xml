<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R on Xiao Song </title>
    <link>/tags/r/</link>
    <description>Recent content in R on Xiao Song </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 25 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/r/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>交叉验证</title>
      <link>/cross/</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/cross/</guid>
      <description>交叉验证是机器学习中的常用模型选择方法。其中最常用的方法是K折交叉验证(k-fold cross validation)。K折交叉验证重复使用数据，把给定的数据切分为K个互斥子集，每次使用1个子集作为测试集，使用余下k-1个子集的并集作为训练集。其中，训练集用于模型的训练，测试集用于模型的评估和选择。在样本量不够充足的情况下，交叉验证法通过重复使用数据能够减少样本划分不同导致的差别，并且选择测试误差最小的模型，增强模型的泛化能力。
交叉验证主要有以下种类：
简单交叉验证 (hold-out cross validation)
k折交叉验证 (K-fold cross-validation)
留一交叉验证(leave-one-out cross validation)
谢益辉的统计动画R包animation直观地展示了交叉验证方法。
#install.packages(&amp;#39;mlbench&amp;#39;)library(caret) #加载数据集10折交叉验证 (K-fold cross-validation)#install.packages(&amp;#39;mlbench&amp;#39;)rfControl &amp;lt;-trainControl( #10折交叉验证method =&amp;quot;cv&amp;quot;, number =10 # Number of folds)library(mlbench) #加载数据集data(BostonHousing)head(BostonHousing) crim zn indus chas nox rm age dis rad tax ptratio b1 0.00632 18 2.31 0 0.538 6.575 65.2 4.0900 1 296 15.3 396.902 0.</description>
    </item>
    
    <item>
      <title>Python算法实现</title>
      <link>/suanfa/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/suanfa/</guid>
      <description>7.7实验 #实验范例（1）：折半查找算法 def BinarySearch(a,target): left = 0 right = len(a) - 1 while left &amp;lt;= right: mid = (left + right)//2 midVal = a[mid] if midVal &amp;lt;target: left = mid + 1 elif midVal &amp;gt; target: right = mid - 1 else: return mid return - 1 L = [5,7,13,25,32,46,54,62,78,83,88,91,99] BinarySearch(L,13)  2  #冒泡排序法 def bubble(List): for j in range(len(List)-1,0,-1): print(List) for i in range(0,j): if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i] return List testlist = [49,38,65,97,76,13,27,49] print(&#39;结果：&#39;,bubble(testlist))  [49, 38, 65, 97, 76, 13, 27, 49] [38, 49, 65, 76, 13, 27, 49, 97] [38, 49, 65, 13, 27, 49, 76, 97] [38, 49, 13, 27, 49, 65, 76, 97] [38, 13, 27, 49, 49, 65, 76, 97] [13, 27, 38, 49, 49, 65, 76, 97] [13, 27, 38, 49, 49, 65, 76, 97] 结果： [13, 27, 38, 49, 49, 65, 76, 97]  实验内容 #（1）找出最大最小值 lst = [31,45,35,56,37,69,310,21,12] def max2(List): for j in range(len(List)-1,0,-1): for i in range(0,j): if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i] return List[len(List)-1] max2(lst)  310  # 找出列表最小值 def min2(List): for j in range(len(List)-1,0,-1): for i in range(0,j): if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i] return List[0] min2(lst)  12  # 折半查找算法，有多个则返回第一个。 def BinarySearch(a,target): left = 0 right = len(a) - 1 while left &amp;lt;= right: mid = (left + right)//2 #整除，提取中点 midVal = a[mid] if midVal &amp;lt; target: #在中点右侧寻找 left = mid + 1 elif midVal &amp;gt; target: #在中点左侧寻找 right = mid - 1 else: return a.</description>
    </item>
    
    <item>
      <title>生存分析云笔记</title>
      <link>/survival/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/survival/</guid>
      <description>本文系复旦大学人口学系张震老师和华东师范大学人口研究所李强老师的数据分析课程笔记。
一个R生存分析应用的介绍网页Survival Analysis with R
两篇重要的中文文献：
李强, 张震. (2009). 生存分析中时间变量的选择[J]. 中国人口科学(6), 88-95.
李强, 徐刚, 陈丽梅.(2019) 生存分析的应用误区[J]. 中国人口科学(01):101-112.
第一讲: 基本概念社会调查只能观察到状态。人口学关心从一个状态到另一个状态转移的风险。试想每一种状态是一个格子，格子内部是人口频数。人口学能通过数频数的方式估计状态转移的风险。在一个状态内待的时间和风险有着密切的关系。\(T\)为随机变量，上帝也不知道
生存函数：\(S(t) = P(T &amp;gt; t)\)。是存活概率也是存活百分比。
失效函数(Failure Function)：\(F(t)\),\(S(t) = 1 - F(t)\), \(F(t)\)是T的累积分布函数。
\(f(t) = \frac{{dF(t)}}{{dt}}\)，即\(S(t)\)的斜率。等价于生存时间的概率密度函数(直方图)。是无条件的风险。
风险函数: \[h(t) = \mathop {\lim }\limits_{\Delta t \to 0} \frac{{P(t \le T &amp;lt; t + \Delta t|T \ge t)}}{{\Delta t}},0 &amp;lt; h(t) &amp;lt; + \infty \]
\(h(t)\)不是密度也不是概率。
censor(删截): 知道事件发生，但不知道事件何时发生。事件观测期内无法观测。truncate(截平): 只有在给定观测期内的个体才会被观测到的状况。样本选择问题。生存函数对应于某种条件概率。</description>
    </item>
    
  </channel>
</rss>