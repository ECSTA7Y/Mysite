<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xiao Song | 宋 骁 on Xiao Song </title>
    <link>/</link>
    <description>Recent content in Xiao Song | 宋 骁 on Xiao Song </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>使用R Studio运行LaTeX</title>
      <link>/rsweave/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/rsweave/</guid>
      <description>我平时喜欢使用LaTeX写文档。而因为种种原因，我一直以来用的是MikTeX（虽然它常常因为简陋的功能为人诟病）。
而之所以不使用TeXmaker或是CTeX是因为它们容易出Bug而且不简约（主要是因为懒得花时间学）。个人认为MikTeX是最轻量级的TeX了。然而，MikTeX的界面过于简单粗暴，并且无法更换背景颜色（我喜欢使用深色界面保护视力，但MikTeX无法修改）。
Figure 1: MikTeX界面然而，R Studio的界面漂亮简单。也可以选择保护视力的深色主题。况且作为R用户，将写作、制作幻灯片、统计分析等工作整合到R Studio也大大提升了工作效率。如何做到这一点呢？
首先要安装LaTeX环境。安装后R会自动识别这个环境。Windows用户请注意，MikTeX一定要安装在全英文路径下！ MikTeX一定要安装在全英文路径下！ MikTeX一定要安装在全英文路径下！
后续需要安装一些R包，如Knitr，tinytex等（具体的R包我就不列出了，如果你没有安装，R会提示你的）。
然后需要配置一下R Studio的环境:
Figure 2: 依次点击Tools - Global Options - Sweave配置Sweave环境其中，Weave Rnw files using选knitr。想要写中文LaTeX文档必须选XeLaTeX环境。
我们点击Open File打开一个LaTeX文档：
Figure 3: 点击Open File打开一个LaTeX文档打开后，可以直接在R Studio中进行编辑写作。完成后，点击上方Complie PDF编译LaTeX文档，如图：
Figure 4: 点击Complie PDF编译LaTeX文档编译成功的PDF文档（是我用于某课程pre的LaTeX Beamer）如图：
Figure 5: 编译好的PDF文档编辑公式我使用Mathtype。它的好处在于可以直接将公式复制为LaTeX代码(需要事先设置好剪切和复制预置选项)：
Figure 6: Mathtype编辑器如，以上的公式可以直接复制为如下的纯文本LaTeX公式：
$$\ln {h_i}(t) = \ln {h_0}(t) + {\beta _1}{X_1} + {\beta _2}{X_2} + \cdot \cdot \cdot + {\beta _p}{X_p}$$使用R Sweave另一个方案是使用R Sweave。</description>
    </item>
    
    <item>
      <title>交叉验证</title>
      <link>/cross/</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/cross/</guid>
      <description>简单交叉验证 (hold-out cross validation)
k折交叉验证 (K-fold cross-validation)
留一交叉验证(leave-one-out cross validation)
谢益辉的统计动画R包animation直观地展示了交叉验证方法。
&amp;gt; #install.packages(&amp;#39;mlbench&amp;#39;)&amp;gt; library(caret) #加载数据集10折交叉验证 (K-fold cross-validation)&amp;gt; #install.packages(&amp;#39;mlbench&amp;#39;)&amp;gt; &amp;gt; rfControl &amp;lt;-trainControl( #10折交叉验证+ method =&amp;quot;cv&amp;quot;, + number =10 # Number of folds+ )&amp;gt; &amp;gt; library(mlbench) #加载数据集&amp;gt; data(BostonHousing)&amp;gt; head(BostonHousing) crim zn indus chas nox rm age dis rad tax ptratio b1 0.00632 18 2.31 0 0.</description>
    </item>
    
    <item>
      <title>Python算法实现</title>
      <link>/suanfa/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/suanfa/</guid>
      <description>7.7实验 #实验范例（1）：折半查找算法 def BinarySearch(a,target): left = 0 right = len(a) - 1 while left &amp;lt;= right: mid = (left + right)//2 midVal = a[mid] if midVal &amp;lt;target: left = mid + 1 elif midVal &amp;gt; target: right = mid - 1 else: return mid return - 1 L = [5,7,13,25,32,46,54,62,78,83,88,91,99] BinarySearch(L,13)  2  #冒泡排序法 def bubble(List): for j in range(len(List)-1,0,-1): print(List) for i in range(0,j): if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i] return List testlist = [49,38,65,97,76,13,27,49] print(&#39;结果：&#39;,bubble(testlist))  [49, 38, 65, 97, 76, 13, 27, 49] [38, 49, 65, 76, 13, 27, 49, 97] [38, 49, 65, 13, 27, 49, 76, 97] [38, 49, 13, 27, 49, 65, 76, 97] [38, 13, 27, 49, 49, 65, 76, 97] [13, 27, 38, 49, 49, 65, 76, 97] [13, 27, 38, 49, 49, 65, 76, 97] 结果： [13, 27, 38, 49, 49, 65, 76, 97]  实验内容 #（1）找出最大最小值 lst = [31,45,35,56,37,69,310,21,12] def max2(List): for j in range(len(List)-1,0,-1): for i in range(0,j): if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i] return List[len(List)-1] max2(lst)  310  # 找出列表最小值 def min2(List): for j in range(len(List)-1,0,-1): for i in range(0,j): if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i] return List[0] min2(lst)  12  # 折半查找算法，有多个则返回第一个。 def BinarySearch(a,target): left = 0 right = len(a) - 1 while left &amp;lt;= right: mid = (left + right)//2 #整除，提取中点 midVal = a[mid] if midVal &amp;lt; target: #在中点右侧寻找 left = mid + 1 elif midVal &amp;gt; target: #在中点左侧寻找 right = mid - 1 else: return a.</description>
    </item>
    
    <item>
      <title>生存分析云笔记</title>
      <link>/survival/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/survival/</guid>
      <description>本文系复旦大学人口学系张震老师和华东师范大学人口研究所李强老师的数据分析课程笔记。
一个R生存分析应用的介绍网页Survival Analysis with R
两篇重要的中文文献：
李强, 张震. (2009). 生存分析中时间变量的选择[J]. 中国人口科学(6), 88-95.
李强, 徐刚, 陈丽梅.(2019) 生存分析的应用误区[J]. 中国人口科学(01):101-112.
第一讲: 基本概念社会调查只能观察到状态。人口学关心从一个状态到另一个状态转移的风险。试想每一种状态是一个格子，格子内部是人口频数。人口学能通过数频数的方式估计状态转移的风险。在一个状态内待的时间和风险有着密切的关系。\(T\)为随机变量，上帝也不知道
生存函数：\(S(t) = P(T &amp;gt; t)\)。是存活概率也是存活百分比。
失效函数(Failure Function)：\(F(t)\),\(S(t) = 1 - F(t)\), \(F(t)\)是T的累积分布函数。
\(f(t) = \frac{{dF(t)}}{{dt}}\)，即\(S(t)\)的斜率。等价于生存时间的概率密度函数(直方图)。是无条件的风险。
风险函数: \[h(t) = \mathop {\lim }\limits_{\Delta t \to 0} \frac{{P(t \le T &amp;lt; t + \Delta t|T \ge t)}}{{\Delta t}},0 &amp;lt; h(t) &amp;lt; + \infty \]
\(h(t)\)不是密度也不是概率。
censor(删截): 知道事件发生，但不知道事件何时发生。事件观测期内无法观测。truncate(截平): 只有在给定观测期内的个体才会被观测到的状况。样本选择问题。生存函数对应于某种条件概率。</description>
    </item>
    
    <item>
      <title>宋 骁</title>
      <link>/chnresume/</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/chnresume/</guid>
      <description>英文简历请点击这里
PDF版本请点击这里下载
联系方式地址：上海市浦东新区芳华路53号邮箱：malcolm@xsong.ltdGithub：https://github.com/ECSTA7Y个人主页：https://xsong.ltd微信公众号：ApocalypseNow软件技能R, LaTeX, Stata (熟练)Python, SQL, SPSS (了解)相关课程R语言数据分析算法与程序设计基础 (Python)回归分析与Stata应用SPSS应用类别数据分析概率与统计导论社会模拟与NetLogo应用教育背景华东师范大学, 社会发展学院 2016年09月-至今中山大学, 学期交换 2018年2月-2018年7月培训经历北京大学-密歇根大学学院 暑期课程 2018年8月
课程：因果推论方法的研究设计和敏感性分析 (总成绩：94/100)
上海大学 第6届·应用社会科学研究方法研修班 2017年7月
课程：Stata与应用回归分析基础，类别数据分析
狗熊会 在线实习项目 2019年5月 课程：信用卡申请评分模型
使用Python的Pandas、Numpy和scikit-learn库进行数据清理、建模。使用Logistic模型和决策树模型建立信用卡评分模型。通过交叉验证(Cross-Validation)的方法训练模型，预测信用卡申请者拖欠账单的概率。最终形成完整的数据分析报告。
科研经历土地流转的福利效应与社会不平等——来自CFPS的经验证据 2018年-2019年</description>
    </item>
    
    <item>
      <title>Python函数与模块的使用</title>
      <link>/pydef/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/pydef/</guid>
      <description>函数与模块的使用 实验范例6.7.2 #(1) def star(m,n): for i in range(m): print(&#39;*&#39;*n) star(3,2)  ** ** **  star(5,6)  ****** ****** ****** ****** ******  star(4,20)  ******************** ******************** ******************** ********************  #(2) def paint(m,s): print(s*m) paint(3,&#39;*&#39;)  ***  paint(8,&#39;%+&#39;)  %+%+%+%+%+%+%+%+  #(3) def check(a): if a&amp;gt;0: print(&#39;&amp;gt;0&#39;) elif a &amp;lt; 0: print(&#39;&amp;lt;0&#39;) else: print(&amp;quot;==0&amp;quot;) check(5)  &amp;gt;0  check(-2)  &amp;lt;0  check(0)  ==0  #(4) def avg(a,b): return(a+b)/2 c = avg(4,6) c  5.</description>
    </item>
    
    <item>
      <title>初中生学习成绩的影响因素: 基于分类与回归树的分析</title>
      <link>/edutree/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/edutree/</guid>
      <description>数据本文采用中国教育追踪调查 (China Education Panel Survey, CEPS)2013-2014学年基线数据。 采用PPS抽样方法，以人口平均受教育水平和人口比例为分层变量并通过两阶段分层抽样从从全国随机抽取了28个县级单位作为调查点。具体而言，CEPS在每个入样县（区）所辖地理范围内分别抽取4所初中学校。并在每所入样学校中分别抽取4个班级，包括2个七年级班和2个九年级班。
模型与算法CART算法全称为分类与回归树（Classification and Regression Trees）。它可以处理分类与回归算法，以及生存分析因变量。作为一种非参数的机器学习方法，CART决策树无需对数据的分布做任何假定。CART算法划分数据的依据是变量的取值顺序，因此它对异常值不敏感。最后，通过交叉验证（Cross Validation）的方法求得预测误差。 回归树模型可表示为： \[f(x) = \sum\limits_{m = 1}^M {{c_m}I(x \in {R_m})} \]
其中，\(x\)是一系列输入特征（自变量），\({R_1},{R_2},...,{R_m}\)是输入空间被划分的M个区域。 是区域\({R_m}\)对应的最优值。\(I\)代表的是指示函数（indicator function），当输入变量\(x\)属于区域 \({R_m}\)时，输出为1，否则输出为0。 CART算法选择基尼系数进行属性划分。CART算法可以运用于分类和回归问题中。
为了防止过拟合问题(Over-fitted),需要对过于复杂的树模型进行剪枝。这也是训练模型的重要过程。通过改善模型的复杂度参数(Complexity Parameter, CP)。在CART算法中，复杂度参数定义如下：
\[{{\rm{C}}_\alpha }(T) = C(T) + \alpha \left| T \right|\]
其中，\(T\)为任意子树。\(C(T)\)为对训练数据的预测误差（如基尼指数）， \(\left| T \right|\)为子树的叶结点个数，\(\alpha \ge 0\)为参数，\({{\rm{C}}_\alpha }(T)\)是参数为\(\alpha\)时的子树\(T\)的整体损失。参数\(\alpha\)测量了模型的复杂度。
变量本研究依据以往教育学和社会学文献，选取了50个自变量进行预测。为了降低测量误差，本研究在变量选取的过程中遵循了以下两个原则：1.尽可能挑选“客观的”变量。2.尽可能挑选直观上对学习成绩有重要影响的变量。
因变量本研究的因变量是被调查学生上一次期中考试的成绩。包括数学成绩、语文成绩、英语成绩。我们将同时对总成绩进行分析。
为了讨论学习成绩的门槛效应，我们将数学成绩是否位于所有学生的前25%(是=1，否=0)单独划分为一个分类变量建立分类树。下图展示了标准化总成绩的密度直方图估计。箱线图展示了编号为1-30的学校的数学原始成绩差异。我们可以发现，标准化总成绩基本上呈现了正态分布。不同学校间的数学成绩差异十分显著。
自变量下面展示了自变量以及自变量在模型中的编码：
家庭变量：每星期零用钱(money)、上兴趣班费用总计(clfee)、监督孩子的作业(qianzi)、花在孩子身上的时间(lifetm)、孩子交流方言(dial)、父母交流方言(chidia)、家长教育期望(eduyexp)、对孩子未来的信心(futcfd)、孩子户口类型(huko)、家长教育程度(eduy)、家长政治面貌(dangy)、住房是否生产经营用(houspro)。
个人变量：性别(sex)、是否独生子女(onechi)、父亲教育水平(faedu)、母亲教育水平(maedu)、爸爸经常酗酒(drunk)、父母经常吵架(qurel)、父母之间关系很好(relation)、有独立书桌(desk)、家里有电脑和网络(net)、家庭交流方言(dialect)、父母督促学习天数(chkhmwk chkcouse)、父母教育期望(eduexp)。
学校变量：学校性质(schtype)、教室数量(schcsrm)、学校电脑数(comno)、图书数量(bknum)、生均财政拨款(buget)、持有教师资格证人数(eduqua)、打架斗殴(fight)、破坏公物(brkpb)、吸烟(smok)、饮酒(drink)、高级教师年收入(teainc)。
班级变量：教师总课时(classtm)、 备课时间(clpre)、批改作业时间(revitm)、班主任教授本班科目(subject)、认识多少家长(know)、是否有抽烟喝酒的学生(drsmok)、与学生交流时间(commhr)。
为了直观地描述不同学校与学习成绩的差异，下面展示了以学校为分组变量，原始数学成绩为因变量的箱线图。
分析结果回归树首先我们将展示总成绩的回归结果。由于七年级和九年级学生考试总分的不同。我们将九年级子样本单独进行分析，并采用10折交叉验证计算模型的验证误差。</description>
    </item>
    
    <item>
      <title>Xiao Song</title>
      <link>/englishresume/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/englishresume/</guid>
      <description>Chinese Resume please click here
CONTACTAdress：No. 53, Fanghua Road, Pudong New Area, ShanghaiEmail：malcolm@xsong.ltdGithub：https://github.com/ECSTA7YWebsite：https://xsong.ltdWechat Official Account：ApocalypseNowSOFTWARE SKILLSR, LaTeX, StataPython, SQL, SPSSRELEVANT COURSESData Analysis Using RAlgorithm and program design (Python)Regression Analysis and Stata ApplicationSPSS ApplicationCategorical Data AnalysisSocial Simulation and NetLogo ApplicationEDUCATIONEast China Normal University 2016-09~Today</description>
    </item>
    
    <item>
      <title>如何提取R包中的小品文? </title>
      <link>/vignette/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/vignette/</guid>
      <description>公众号文章 《如何提取R包中的小品文》请点击这里
用R实现各种分析任务需要学习不同的R包。而学习R包实现方法的同时必须同时结合理论。因此仅仅看帮助文档和用户手册（Reference manual）是远远不够的。作为学习R包的重要资源，小品文（Vignettes，或翻译为简介）将统计理论、代码与示例相结合，是学习数据分析的不可多得的好材料。下文将以rpart包为例讲解如何获取R包的官方小品文。
在CRAN上发布的R包往往会有一个官方主页。在搜索引擎中键入R rpart或CRAN rpart便能够找到此包主页。
rpart的官方主页如下所示：
其中，Downloads一栏下便有用户手册和小品文的下载按钮，点击即可下载。
但是，这种方法其实多此一举了！
因为我们在下载R包时，已经将小品文下载下来了。我们可以使用utils包中的vignette函数自动提取小品文。但首先我们需要提取R包的小品文名称，代码如下：
&amp;gt; #install.packages(&amp;#39;utils&amp;#39;)#没安装先安装包&amp;gt; #library(utils)#加载包&amp;gt; vignette(, package = &amp;quot;rpart&amp;quot;)#提取rpart包的小品文名称输出结果如下所示：
&amp;gt; #Vignettes in package ‘rpart’:&amp;gt; &amp;gt; #longintro Introduction to Rpart &amp;gt; # (source, pdf)&amp;gt; #usercode User Written Split&amp;gt; # Functions (source, pdf)可以发现，rpart包有两篇小品文，《Introduction to Rpart》和《User Written Split Functions》。分别简称为“longintro”和“usercode”。现在，就可以根据简称提取小品文了，输入：
&amp;gt; vignette(&amp;quot;longintro&amp;quot;, package = &amp;quot;rpart&amp;quot;)第一篇《Introduction to Rpart》的pdf便会自动跳出：
便可以阅读了。
很多R包的小品文是pdf版本，当然还有很多是html形式的，如ggplot2的小品文：
&amp;gt; vignette(&amp;quot;ggplot2-specs&amp;quot;, package = &amp;quot;ggplot2&amp;quot;)看起来这个小品文是用R Markdown写的。</description>
    </item>
    
    <item>
      <title>Zhuangzi and David Lewis</title>
      <link>/zhuangzi/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>/zhuangzi/</guid>
      <description>One day, Zhuangzi is washing his feet. When he put his feet on the water, he was burned. Zhuangzi felt shocked and drop his hands to water to try the temperature. He felt it is just warm water. He cried: “Ay! Even my senses are so erratic and inexplicable. It seems that our feelings are cheating to us! If our feelings are deceptive, what is the meaning of our life’s pain?</description>
    </item>
    
    <item>
      <title>科学预测和因果关系</title>
      <link>/casual/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/casual/</guid>
      <description>摘要：因果关系在世界中普遍存在，具体科学所做的主要工作就是对世界各个领域的因果关系加以解释。如果关于因果关系的知识通过人类的科学活动而获得，人类就可以通过因果关系对未来进行预测。但是，人们通常所谈的因果关系常常具有不同的意义。有时人们能通过因果关系准确地预测未来发生的事件。有时却即便掌握了因果关系却仍然无法有效预测。因果概念的相互混淆在科学研究中是无法接受的。本文试图运用严格的逻辑演绎厘请这些关系。
关键词：预测 科学技术哲学 因果关系
预测问题：人们如何预测？人们预测未来所发生的事情通常采用两种方法：一种是默会的方式，占星术、算命、占卜、风水都属于默会。这种方法通过一些随意的线索拼凑未来的图景，试图用各种各样的方式将自己的说法合理化。另一种是科学的方式，这种预测建立在严格的因果解释上。一旦所有的相关条件被控制之后。只要一个原因被满足了，那么相应的结果必定会出现。一旦我们掌握了足够多的关于因果关系的知识，我们就可以预测在什么样的条件下产生什么样的结果，而且这种预测是必然的。至少其准确度要高于默会式的预测。 笔者想要强调的2个重点是：
（a）科学的预测建立在必然性质的因果关系之上，而这种预测甚至不需要原因事件的发生。
（b）只有科学的预测才是真正的、唯一可能的预测。
因为默会的预测会遇到一些问题。请注意，这里我把默会方式的预测规定为不依赖任何因果关系的预测。有些占卜高手也能够预测得想当准确，这是因为他们在无意中借助了因果关系。这种预测我们也暂且称之为科学的预测。 而因果预测最奇妙的一点就是我们并不需要因果关系的前提存在，笔者将在后文中讨论这一点。科学家们只需要罗列出各种前提的可能性，就能知道什么事件将会在接下来的时间发生。因为因果关系是必然的联系，甚至可能是（按照休谟的说法）唯一必然的联系。任何想要脱离必然性的预测，都将会是偶然的。这就是默会预测不可能实现的原因。
因果关系纵观西方哲学史，最早对因果进行思考的哲学家是亚里士多德，他提出的“四因说”是西方哲学史第一次对因果关系的系统讨论。但亚里士多德的讨论充满了模糊之处。直到大卫·休谟的分析明确提出了“充分必要条件”的因果观。但事实上，后世的哲学家发现，仅用休谟对因果关系的定义是无法令人满意的。似乎还存在着其他意义上的因果关系。 科学的研究追求普遍性。尽管每一个个体事件都是有原因的，但是科学的目的并不是列举每一个事件的原因。而是对事物的因果机制进行抽象，表达普遍性的因果关系。科学活动并不关心在某一个特定地点“水沸腾”这一事件的原因，而是要探索在任意条件下，在任何情境下水沸腾的因果机制。按照古德曼的理论，科学定律与偶适概括的区别就在于，科学定律具有全称必然性。而偶适定律没有(Goodman 1983)。比方说，所有“水沸腾”的必然原因都是（1）在标准大气压下（2）持续加热（3）加热到100℃。而“\(x\)是人”并不是“\(x\)有两条腿”的必然原因。 因此，本文的讨论将着眼于全称必然意义上的因果规则。
休谟充分必要条件因果观及其受到的批判按照大卫·休谟和之后对因果关系的解释和定义，两事件A、B具有因果关系，当且仅当： A事件发生B事件将会发生（\(A \to {\rm{B}}\)） A事件不发生B事件也不会发生。（\(\neg {\rm{A}} \to \neg {\rm{B}}\)） B事件在A事件之后发生（此处并不必然指事件的时间先后顺序，也可能是心灵意向的时间先后顺序。如“某人推门，门开”这一组因果关系，这两个动作是同时发生的。但是，推门者推门的意向必定是先于此动作而发生的。） 根据逻辑分析，我们可以看出，A和B互为充分必要条件。A为原因，B为结果。 后世哲学家们对休谟因果观的发起了批判。比如：金在权(Kim 1974)就曾经提出过关于此定义本身的几个反例，但这些反例并不是笔者所关注的重点。 对休谟定义的一个重大批判和发展来自约翰·密尔。他认为，休谟将因果关系简化为两个事件。事实上，在复杂的现实世界，这样简单的因果关系是非常少见的。现实生活中往往会出现一因多果，一果多因，甚至互为因果的情况(韩林合 2013)。 笔者认为科学定律的普遍形式是：
\[\forall x\Box ({R_1} \wedge {R_2} \wedge ... \wedge {R_n} \wedge {P_x} \to {Q_x})\]
这里的\({R_1},{R_2},{R_3},...,{R_{n - 1}},{R_n}\)表示第n个相关条件。那么什么是相关条件呢？让我们举一个简单的例子：
“在标准大气压并且持续加热的情况下，水（必然）会在100℃时沸腾。” 
注：“在标准大气压下” = \({R_1}\), “持续加热” = \({R_2}\), “\(x\)被加热至100℃” = \({R_3}\), “\(x\)沸腾” = \(Q_x\)。
事实上，相关条件的思想对应于科学实验中的随机分组与控制变量。当控制了“在标准大气压下”和 “持续加热”这两个条件不变时，“水在100℃”构成了“水沸腾”的强决定因果，“水沸腾”当且仅当“水在100℃”。 那么这条定律可以重新写成：</description>
    </item>
    
    <item>
      <title>Reward</title>
      <link>/reward/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/reward/</guid>
      <description>赞赏支付宝 (Alipay)微信 (Wechat)</description>
    </item>
    
  </channel>
</rss>