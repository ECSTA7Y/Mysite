<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xiao Song | 宋 骁 on Xiao Song </title>
    <link>/</link>
    <description>Recent content in Xiao Song | 宋 骁 on Xiao Song </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 25 May 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>交叉验证</title>
      <link>/2019/05/25/cross/</link>
      <pubDate>Sat, 25 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/05/25/cross/</guid>
      <description>简单交叉验证 (hold-out cross validation)
k折交叉验证 (K-fold cross-validation)
留一交叉验证(leave-one-out cross validation)
&amp;gt; #install.packages(&amp;#39;mlbench&amp;#39;)&amp;gt; library(caret) #加载数据集10折交叉验证 (K-fold cross-validation)&amp;gt; #install.packages(&amp;#39;mlbench&amp;#39;)&amp;gt; &amp;gt; rfControl &amp;lt;-trainControl( #10折交叉验证+ method =&amp;quot;cv&amp;quot;, + number =10 # Number of folds+ )&amp;gt; &amp;gt; library(mlbench) #加载数据集&amp;gt; data(BostonHousing)&amp;gt; head(BostonHousing) crim zn indus chas nox rm age dis rad tax ptratio b1 0.00632 18 2.31 0 0.538 6.</description>
    </item>
    
    <item>
      <title>算法实现与性能分析</title>
      <link>/2019/05/24/suanfa/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/05/24/suanfa/</guid>
      <description>#实验范例（1）：折半查找算法 def BinarySearch(a,target): left = 0 right = len(a) - 1 while left &amp;lt;= right: mid = (left + right)//2 midVal = a[mid] if midVal &amp;lt;target: left = mid + 1 elif midVal &amp;gt; target: right = mid - 1 else: return mid return - 1 L = [5,7,13,25,32,46,54,62,78,83,88,91,99] BinarySearch(L,13)  2  #冒泡排序法 def bubble(List): for j in range(len(List)-1,0,-1): print(List) for i in range(0,j): if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i] return List testlist = [49,38,65,97,76,13,27,49] print(&#39;结果：&#39;,bubble(testlist))  [49, 38, 65, 97, 76, 13, 27, 49] [38, 49, 65, 76, 13, 27, 49, 97] [38, 49, 65, 13, 27, 49, 76, 97] [38, 49, 13, 27, 49, 65, 76, 97] [38, 13, 27, 49, 49, 65, 76, 97] [13, 27, 38, 49, 49, 65, 76, 97] [13, 27, 38, 49, 49, 65, 76, 97] 结果： [13, 27, 38, 49, 49, 65, 76, 97]  实验内容 #（1）找出最大最小值 lst = [31,45,35,56,37,69,310,21,12] def max2(List): for j in range(len(List)-1,0,-1): for i in range(0,j): if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i] return List[len(List)-1] max2(lst)  310  # 找出列表最小值 def min2(List): for j in range(len(List)-1,0,-1): for i in range(0,j): if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i] return List[0] min2(lst)  12  # 折半查找算法，有多个则返回第一个。 def BinarySearch(a,target): left = 0 right = len(a) - 1 while left &amp;lt;= right: mid = (left + right)//2 #整除，提取中点 midVal = a[mid] if midVal &amp;lt; target: #在中点右侧寻找 left = mid + 1 elif midVal &amp;gt; target: #在中点左侧寻找 right = mid - 1 else: return a.</description>
    </item>
    
    <item>
      <title>生存分析云笔记</title>
      <link>/2019/05/23/survival/</link>
      <pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/05/23/survival/</guid>
      <description>本文来源于复旦大学人口学系张震老师的数据分析课程笔记。
第一讲: 基本概念社会调查只能观察到状态。人口学关心从一个状态到另一个状态转移的风险。试想每一种状态是一个格子，格子内部是人口频数。人口学能通过数频数的方式估计状态转移的风险。在一个状态内待的时间和风险有着密切的关系。\(T\)为随机变量，上帝也不知道
生存函数：\(S(t) = P(T &amp;gt; t)\)。是存活概率也是存活百分比。
失效函数(Failure Function)：\(F(t)\),\(S(t) = 1 - F(t)\), \(F(t)\)是T的累积分布函数。
\(f(t) = \frac{{dF(t)}}{{dt}}\)，即\(S(t)\)的斜率。等价于生存时间的概率密度函数(直方图)。是无条件的风险。
风险函数: \[h(t) = \mathop {\lim }\limits_{\Delta t \to 0} \frac{{P(t \le T &amp;lt; t + \Delta t|T \ge t)}}{{\Delta t}},0 &amp;lt; h(t) &amp;lt; + \infty \]
\(h(t)\)不是密度也不是概率。
censor(删截): 知道事件发生，但不知道事件何时发生。事件观测期内无法观测。truncate(截平): 只有在给定观测期内的个体才会被观测到的状况。样本选择问题。生存函数对应于某种条件概率。
censor涉及到事件，truncate涉及到暴露量。
能活到预期寿命者总是62%
第二讲: 最大似然估计(MLE)Cox回归避开了模型分布假定的问题。
假定数据独立同分布。
似然函数：
\[{\rm{L(}}\lambda {\rm{) = }}\prod\limits_{i = 1}^\pi {P(T = t)}\]</description>
    </item>
    
    <item>
      <title>Python基础函数</title>
      <link>/2019/05/10/pybasic/</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/05/10/pybasic/</guid>
      <description>博客园文章《Python基础函数》请点击这里</description>
    </item>
    
    <item>
      <title>宋 骁</title>
      <link>/chnresume/</link>
      <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/chnresume/</guid>
      <description>英文简历请点击这里
PDF版本请点击这里下载
联系方式  地址：上海市浦东新区芳华路53号 邮箱：malcolm@xsong.ltd Github：https://github.com/ECSTA7Y 个人主页：https://xsong.ltd 微信公众号：ApocalypseNow  软件技能  R, LaTeX, Stata &amp;emsp;(熟练) Python, SQL, SPSS &amp;emsp;(了解)  相关课程  R语言数据分析 算法与程序设计基础 (Python) 回归分析与Stata应用 SPSS应用 类别数据分析 概率与统计导论 社会模拟与NetLogo应用  教育背景  华东师范大学, 社会发展学院 &amp;emsp;2016年09月-至今 中山大学, 学期交换 &amp;emsp;2018年2月-2018年7月  培训经历  北京大学-密歇根大学学院 暑期课程 &amp;emsp;2018年8月
课程：因果推论方法的研究设计和敏感性分析 (总成绩：94/100)
 上海大学 第6届·应用社会科学研究方法研修班 &amp;emsp;2017年7月
课程：Stata与应用回归分析基础，类别数据分析
 狗熊会 在线实习项目 &amp;emsp;2019年5月&amp;emsp;
课程：信用卡申请评分模型
使用Python的Pandas、Numpy和scikit-learn库进行数据清理、建模。使用Logistic模型和决策树模型建立信用卡评分模型。通过交叉验证(Cross-Validation)的方法训练模型，预测信用卡申请者拖欠账单的概率。最终形成完整的数据分析报告。
  科研经历  土地流转的福利效应与社会不平等——来自CFPS的经验证据&amp;emsp;2018年-2019年
国家大学生创新训练项目&amp;emsp; 独立作者
使用中国家庭追踪调查(CFPS)数据，通过Stata和R进行数据清理和计量经济分析。使用无条件分位数回归和固定效应模型估计土地流转行为的福利效应和对社会不平等的影响。使用ggplot2软件包进行地理信息可视化。输出图表并最终形成约12000 字的研究论文。
点击这里下载全文。  所获奖项  2019年 第二届全国高校数据驱动创新研究大赛&amp;emsp;优秀奖 2018年 第十二届本科生社会科学论坛&amp;emsp;特等奖 2018年 华东师范大学优秀学生二等奖学金 2017年 华东师范大学优秀学生二等奖学金  实习经历  俺来也 · 西游早餐&amp;emsp;校园经理&amp;emsp;2017年9月-2018年1月</description>
    </item>
    
    <item>
      <title>使用R Sweave运行LaTeX</title>
      <link>/2019/05/09/rsweave/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/05/09/rsweave/</guid>
      <description>公众号文章《使用R Sweave运行LaTeX》请点击这里</description>
    </item>
    
    <item>
      <title>Python函数与模块的使用</title>
      <link>/2019/05/08/pydef/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/05/08/pydef/</guid>
      <description>函数与模块的使用 实验范例6.7.2 #(1) def star(m,n): for i in range(m): print(&#39;*&#39;*n) star(3,2)  ** ** **  star(5,6)  ****** ****** ****** ****** ******  star(4,20)  ******************** ******************** ******************** ********************  #(2) def paint(m,s): print(s*m) paint(3,&#39;*&#39;)  ***  paint(8,&#39;%+&#39;)  %+%+%+%+%+%+%+%+  #(3) def check(a): if a&amp;gt;0: print(&#39;&amp;gt;0&#39;) elif a &amp;lt; 0: print(&#39;&amp;lt;0&#39;) else: print(&amp;quot;==0&amp;quot;) check(5)  &amp;gt;0  check(-2)  &amp;lt;0  check(0)  ==0  #(4) def avg(a,b): return(a+b)/2 c = avg(4,6) c  5.</description>
    </item>
    
    <item>
      <title>初中生学习成绩的影响因素: 基于分类与回归树的分析</title>
      <link>/2019/05/08/edutree/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/05/08/edutree/</guid>
      <description>数据本文采用中国教育追踪调查 (China Education Panel Survey, CEPS)2013-2014学年基线数据。 采用PPS抽样方法，以人口平均受教育水平和人口比例为分层变量并通过两阶段分层抽样从从全国随机抽取了28个县级单位作为调查点。具体而言，CEPS在每个入样县（区）所辖地理范围内分别抽取4所初中学校。并在每所入样学校中分别抽取4个班级，包括2个七年级班和2个九年级班。
模型与算法CART算法全称为分类与回归树（Classification and Regression Trees）。它可以处理分类与回归算法，以及生存分析因变量。作为一种非参数的机器学习方法，CART决策树无需对数据的分布做任何假定。CART算法划分数据的依据是变量的取值顺序，因此它对异常值不敏感。最后，通过交叉验证（Cross Validation）的方法求得预测误差。 回归树模型可表示为： \[f(x) = \sum\limits_{m = 1}^M {{c_m}I(x \in {R_m})} \]
其中，\(x\)是一系列输入特征（自变量），\({R_1},{R_2},...,{R_m}\)是输入空间被划分的M个区域。 是区域\({R_m}\)对应的最优值。\(I\)代表的是指示函数（indicator function），当输入变量\(x\)属于区域 \({R_m}\)时，输出为1，否则输出为0。 CART算法选择基尼系数进行属性划分。CART算法可以运用于分类和回归问题中。
因变量本研究的因变量是被调查学生上一次期中考试的成绩。包括数学成绩、语文成绩、英语成绩。我们将同时对总成绩进行分析。
为了讨论学习成绩的门槛效应，我们将数学成绩是否位于所有学生的前25%(是=1，否=0)单独划分为一个分类变量建立分类树。下图展示的是标准成绩的直方图。
自变量下面展示了自变量以及自变量在模型中的编码：
家庭变量：每星期零用钱(money)、上兴趣班费用总计(clfee)、监督孩子的作业(qianzi)、花在孩子身上的时间(lifetm)、孩子交流方言(dial)、父母交流方言(chidia)、家长教育期望(eduyexp)、对孩子未来的信心(futcfd)、孩子户口类型(huko)、家长教育程度(eduy)、家长政治面貌(dangy)、住房是否生产经营用(houspro)。
个人变量：性别(sex)、是否独生子女(onechi)、父亲教育水平(faedu)、母亲教育水平(maedu)、爸爸经常酗酒(drunk)、父母经常吵架(qurel)、父母之间关系很好(relation)、有独立书桌(desk)、家里有电脑和网络(net)、家庭交流方言(dialect)、父母督促学习天数(chkhmwk chkcouse)、父母教育期望(eduexp)。
学校变量：学校性质(schtype)、教室数量(schcsrm)、学校电脑数(comno)、图书数量(bknum)、生均财政拨款(buget)、持有教师资格证人数(eduqua)、打架斗殴(fight)、破坏公物(brkpb)、吸烟(smok)、饮酒(drink)、高级教师年收入(teainc)。
班级变量：教师总课时hra07 (classtm)、 备课时间(clpre)、批改作业时间(revitm)、班主任教授本班科目(subject)、认识多少家长(know)、是否有抽烟喝酒的学生(drsmok)、与学生交流时间(commhr)
为了直观地描述不同学校与学习成绩的差异，下面展示了以学校为分组变量，原始数学成绩为因变量的箱线图。
下面展示的是数学原始成绩是否位于前25%的分类决策树。首先，我们在备选的约50个自变量中纳入学校哑变量。仅考虑家庭、个体、班级因素对学生学习成绩的影响。通过划分训练集和测试集的方式计算模型的预测错误率。检验模型的泛化能力。
&amp;gt; set.seed(1212323) #设置随机数种子&amp;gt; sampled &amp;lt;- sample(1:nrow(ceps),nrow(ceps)*0.3,replace=FALSE) #抽取30%样本作为验证集&amp;gt; test &amp;lt;- ceps[sampled,] #测试集&amp;gt; train &amp;lt;- ceps[-sampled,] #训练集&amp;gt; &amp;gt; cont &amp;lt;- rpart.control(minsplit=5,maxcompete=100,xval=10,maxdepth=30,cp=0.01) #设置参数&amp;gt; &amp;gt; cltree3 &amp;lt;- rpart(matgreat ~ schids + sex + onechi + maedu + faedu + drunk + + qurel + relation + desk + net + dialect + chkhmwk + chkcouse + + classtm + clpre + revitm + subject + know + drsmok + commhr + + schtype + schcsrm + comno + bknum + buget + eduqua + fight + + brkpb + smok + drink + teainc + money + clfee + qianzi + lifetm + + dial + chidia + futcfd + huko + eduy + dangy + houspro ,data = + subset(train,grade9 == 1),weights = sweight,method = &amp;quot;class&amp;quot;,parms = + list(split=&amp;quot;gini&amp;quot;),control=cont,na.</description>
    </item>
    
    <item>
      <title>Xiao Song</title>
      <link>/englishresume/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/englishresume/</guid>
      <description>Chinese Resume please click here
CONTACT  Adress：No. 53, Fanghua Road, Pudong New Area, Shanghai Email：malcolm@xsong.ltd Github：https://github.com/ECSTA7Y Website：https://xsong.ltd Wechat Official Account：ApocalypseNow  SOFTWARE SKILLS  R, LaTeX, Stata Python, SQL, SPSS  RELEVANT COURSES  Data Analysis Using R Algorithm and program design (Python) Regression Analysis and Stata Application SPSS Application Categorical Data Analysis Social Simulation and NetLogo Application  EDUCATION  East China Normal University&amp;emsp;2016-09~Today
School of Social Development&amp;emsp;(Overall GPA：3.</description>
    </item>
    
    <item>
      <title>如何提取R包中的小品文</title>
      <link>/2019/05/07/vignette/</link>
      <pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/05/07/vignette/</guid>
      <description>公众号文章 《如何提取R包中的小品文》请点击这里
用R实现各种分析任务需要学习不同的R包。而学习R包实现方法的同时必须同时结合理论。因此仅仅看帮助文档和用户手册（Reference manual）是远远不够的。作为学习R包的重要资源，小品文（Vignettes，或翻译为简介）将统计理论、代码与示例相结合，是学习数据分析的不可多得的好材料。下文将以rpart包为例讲解如何获取R包的官方小品文。
在CRAN上发布的R包往往会有一个官方主页。在搜索引擎中键入R rpart或CRAN rpart便能够找到此包主页。
rpart的官方主页如下所示：
其中，Downloads下便有用户手册和小品文的下载按钮，点击即可下载。
但，这种方法其实是多此一举了！
因为我们在下载R包时，已经将小品文下载下来了。我们可以使用utils包中的vignette函数自动提取小品文。但首先我们需要提取R包的小品文名称，代码如下：
&amp;gt; #install.packages(&amp;#39;utils&amp;#39;)#没安装先安装包&amp;gt; #library(utils)#加载包&amp;gt; vignette(, package = &amp;quot;rpart&amp;quot;)#提取rpart包的小品文名称输出结果如下所示：
&amp;gt; #Vignettes in package ‘rpart’:&amp;gt; &amp;gt; #longintro Introduction to Rpart &amp;gt; # (source, pdf)&amp;gt; #usercode User Written Split&amp;gt; # Functions (source, pdf)可以发现，rpart包有两篇小品文，《Introduction to Rpart》和《User Written Split Functions》。分别简称为“longintro”和“usercode”。现在，就可以根据简称提取小品文了，输入：
&amp;gt; vignette(&amp;quot;longintro&amp;quot;, package = &amp;quot;rpart&amp;quot;)第一篇《Introduction to Rpart》的pdf便会自动跳出：
便可以阅读了。
很多R包的小品文是pdf版本，当然还有很多是html版的，如ggplot2的小品文：
&amp;gt; vignette(&amp;quot;ggplot2-specs&amp;quot;, package = &amp;quot;ggplot2&amp;quot;)看起来这个小品文是用R Markdown写的。</description>
    </item>
    
    <item>
      <title>科学预测和因果关系</title>
      <link>/2017/08/01/casual/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/08/01/casual/</guid>
      <description>预测问题：人们如何预测？人们预测未来所发生的事情通常采用两种方法：一种是默会的方式，占星术、算命、占卜、风水都属于默会。这种方法通过一些随意的线索拼凑未来的图景，试图用各种各样的方式将自己的说法合理化。另一种是科学的方式，这种预测建立在严格的因果解释上。一旦所有的相关条件被控制之后。只要一个原因被满足了，那么相应的结果必定会出现。一旦我们掌握了足够多的关于因果关系的知识，我们就可以预测在什么样的条件下产生什么样的结果，而且这种预测是必然的。至少其准确度要高于默会式的预测。 笔者想要强调的几个重点是：
（a）科学的预测建立在必然性质的因果关系之上，而这种预测甚至不需要原因事件的发生。
（b）只有科学的预测才是真正的、唯一可能的预测。
因为默会的预测会遇到一些问题。请注意，这里我把默会方式的预测规定为不依赖任何因果关系的预测。有些占卜高手也能够预测得想当准确，这是因为他们在无意中借助了因果关系。这种预测我们也暂且称之为科学的预测。 而因果预测最奇妙的一点就是我们并不需要因果关系的前提存在，笔者将在后文中讨论这一点。科学家们只需要罗列出各种前提的可能性，就能知道什么事件将会在接下来的时间发生。因为因果关系是必然的联系，甚至可能是（按照休谟的说法）唯一必然的联系。任何想要脱离必然性的预测，都将会是偶然的。这就是默会预测不可能实现的原因。
因果关系从哲学史来看，最早对因果进行思考的哲学家是亚里士多德，他提出的“四因说”是西方哲学史第一次对因果关系的系统讨论。但亚里士多德的讨论充满了模糊之处。直到大卫·休谟的分析明确提出了“充分必要条件”的因果观。但事实上，后世的哲学家发现，仅用休谟对因果关系的定义是无法令人满意的。似乎还存在着其他意义上的因果关系。 科学的研究追求普遍性。尽管每一个个体事件都是有原因的，但是科学的目的并不是列举每一个事件的原因。而是对事物的因果机制进行抽象，表达普遍性的因果关系。科学活动并不关心在某一个特定地点“水沸腾”这一事件的原因，而是要探索在任意条件下，在任何情境下水沸腾的因果机制。按照古德曼的理论，科学定律与偶适概括的区别就在于，科学定律具有全称必然性。而偶适定律没有（陈晓平，2001；Goodman，1983）。比方说，所有“水沸腾”的必然原因都是（1）在标准大气压下（2）持续加热（3）加热到100℃。而“x是人”并不是“x有两条腿”的必然原因。 因此，本文的讨论将着眼于全称必然意义上的因果规则。
休谟充分必要条件因果观及其受到的批判按照大卫·休谟和之后对因果关系的解释和定义，两事件A、B具有因果关系，当且仅当： A事件发生B事件将会发生（A→B） A事件不发生B事件也不会发生。（¬A→¬B） B事件在A事件之后发生（此处并不必然指事件的时间先后顺序，也可能是心灵意向的时间先后顺序。如“某人推门，门开”这一组因果关系，这两个动作是同时发生的。但是，推门者推门的意向必定是先于此动作而发生的。） 根据逻辑分析，我们可以看出，A和B互为充分必要条件。A为原因，B为结果。 后世哲学家们对休谟因果观的发起了批判。比如：金在权（Kim,1973）就曾经提出过关于此定义本身的几个反例，但这些反例并不是笔者所关注的重点。 对休谟定义的一个重大批判和发展来自约翰·密尔。他认为，休谟将因果关系简化为两个事件。事实上，在复杂的现实世界，这样简单的因果关系是非常少见的。现实生活中往往会出现一因多果，一果多因，甚至互为因果的情况（韩林合，2013）。 笔者认为科学定律的普遍形式是：
\[\forall x\Box ({R_1} \wedge {R_2} \wedge ... \wedge {R_n} \wedge {P_x} \to {Q_x})\]
这里的R1、R2…Rn表示第n个相关条件。那么什么是相关条件呢？让我们举一个简单的例子：
“在标准大气压并且持续加热的情况下，水（必然）会在100℃时沸腾。” 注：“在标准大气压下”。“持续加热”= “x在100℃”= x沸腾”=\(Q_x\)事实上，相关条件的思想对应于科学实验中的随机分组与控制变量。当控制了“在标准大气压下”和 “持续加热”这两个条件不变时，“水在100℃”构成了“水沸腾”的强决定因果，“水沸腾”当且仅当“水在100℃”。 那么这条定律可以重新写成：
\[\forall x\Box({R_1} \wedge {R_2} \wedge ... \wedge {R_n} \wedge {P_x} \leftrightarrow {Q_x})\]
我们并没有忽略造成“水沸腾”的任何一个原因。一旦所有造成“水沸腾”的条件全部满足，水必然会沸腾。由于并没有其他原因能造成水的沸腾，因此我们能从水沸腾必然地推出上述的三个条件。可见，我们找出了“水沸腾”的充分必要条件的因果关系。一旦其他相关条件被实现并且保持不变，那么其中任何一个相关条件的变化都可以成为“水沸腾”的充分必要的原因。比方说，当我们控制“持续加热”和“水在100℃”这两个条件，气压的变化同样能够成为水是否沸腾的充分必要的原因。而之所以我们通常不说“气压变化造成水的沸腾”是因为，气压通常是稳定的而且变化幅度不大。在自然状态下无法造成非常大的影响。而温度则在自然界中是一个相对于气压来说变化幅度较大的变量。 在相关条件被控制的情况下，其中的一个核心条件的变化都是结果变化的充分条件。比方说，当1）在标准大气压下（2）持续加热 这两个条件被满足的情况下，从“加热到100℃”我们必然能推出“水沸腾”。 而相关条件和核心条件共同构成结果的充分必要条件。比如（1）在标准大气压下（2）持续加热（3）加热到100℃ 是“水沸腾”的充分必要条件。
事实上，休谟也曾以较为粗略的语言表述过关于多个原因的复杂事件的思想。但是密尔将其精细化了。密尔对于因果关系的另一个重要的贡献就是对负事件的表述。
密尔认为，构成一个结果事件的原因往往包含着一些负事件。即一些事件的缺席。比方说：造成K因癌症而死的原因是K没有在肿瘤恶化之前做手术、K没有及时发现自己的症状。 Q能准时到达某地点是因为没有堵车，没有发生交通事故等等。尽管密尔并不承认负事件能够作为真正的原因。但是，一些哲学家（如Mackie）认为负事件可以是真正的原因。对于单称事件来说，纳入负事件作为原因将会使原因的合取枝趋于无穷。然而，笔者认为对于全称因果关系，负事件的影响将不是强决定的。在某种意义下，负事件甚至不是一个存在的事件（韩林合，2013）。
如果任何因果关系都像如上定义的那样为充分必要条件关系的话。再加上另一个条件，即：万事万物都是有原因的1。那么我们会得出这样的结论：我们可以预测到未来发生的一切事件。因此笔者对休谟的因果定义提出自己的诘难：
决定论论证：
前提（1）：对于任何事件x，都存在事件y，y是x的原因。
前提（2）：y是x的原因事件，当且仅当，y是x的充分必要条件，且y的发生先于x
结论：假设世界的事件序列为C1,…,Cn。前一个事件是后一个事件的原因。从最初的事件C1我们必定能推出（预测）到它之后发生的任何事件Cn。
这条结论是不折不扣的因果决定论(Hoefer, 2016)2。如果我们接受以上的论证，我们就将面对决定论所面对过的一切困难。其中一个困难就是我们的结论和前提(1)是不相容的。如果任何事件都有其原因，那么为什么最初的事件C1就没有原因呢？而且，如果这条因果链条一开始就被规定好了的话，我们将如何解释随机事件的存在呢？ 以上的种种困难的出现促使我们重新思考此论证。对于前提(1)，我们是同意的。因为不可能存在着空穴来风的事件。任何事件都有着一定的原因。但是关于随机事件的因果。比方说，掷骰子。我们显然无法通过因果关系预测到骰子的下一个数字。类似于这类随机事件是不适于以上的决定论论证的。但至少，骰子的存在部分地决定了骰子的数字。如果骰子不存在的话，我们当然不能掷出任何一个数字。骰子的存在是对于掷出1~6这6个事件的必要条件。这种“因果关系”显然不符合休谟所定义的充分必要条件的因果关系。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Thu, 05 May 2016 21:48:51 -0700</pubDate>
      
      <guid>/about/</guid>
      <description>This is a &amp;ldquo;hello world&amp;rdquo; example website for the blogdown package. The theme was forked from @jrutheiser/hugo-lithium-theme and modified by Yihui Xie.</description>
    </item>
    
    <item>
      <title></title>
      <link>/resume/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/resume/</guid>
      <description>宋 骁code{white-space: pre;}pre:not([class]) {background-color: white;}if (window.hljs) {hljs.configure({languages: []});hljs.initHighlightingOnLoad();if (document.readyState &amp;&amp; document.readyState === &#34;complete&#34;) {window.setTimeout(function() { hljs.initHighlighting(); }, 0);}}h1 {font-size: 34px;}h1.title {font-size: 38px;}h2 {font-size: 30px;}h3 {font-size: 24px;}h4 {font-size: 18px;}h5 {font-size: 16px;}h6 {font-size: 12px;}.</description>
    </item>
    
  </channel>
</rss>