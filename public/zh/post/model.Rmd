---
title: 'R模型可视化'
subtitle: ' '
author: '[宋骁](https://xsong.ltd)'
date: '2019-10-01'
output:
  bookdown::html_document2:
    toc: true
    theme: readable
slug: model
---

![](https://img.shields.io/badge/License-CC%20BY--NC--ND%204.0-brightgreen.svg)

PDF版本[下载](/modelpdf.pdf)

[English Version](https://www.kaggle.com/rikdifos/r-model-visualization-a-r-markdown-report/report)


模型可视化是应用统计学的重要内容。任何模型都离不开结果的可视化。所谓*模型*，不过是将一堆散点简化为一条线。结果的可视化需要预测值。Hadley Wickham的`modelr`包提供用于预测的函数。预测的结果可以直接被`ggplot2`使用并画图。`modelr`支持管道操作，是将数据分析流程化的利器。  

`modelr`包的主要函数有：

`data_grid`: 生成预测数据

`add_predictions`: 加入预测值

`crossv_kfold`、`crossv_mc`、`crossv_loo`: 交叉验证


```{r,message=F,warning=F,error=T,comment=NA}
library(dplyr)
library(tidyr)
library(ggplot2)
library(modelr)
library(haven)
library(cowplot)
library(stargazer)
`%>%` <- magrittr::`%>%`
```

# 基础回归

`hatdt`为作者个人整理的[中国家庭追踪调查](http://www.isss.pku.edu.cn/cfps/index.htm)(CFPS)收入数据^[可从[Github](https://github.com/ECSTA7Y/MaLearning/blob/master/aggregrate.csv)下载]。

```{r,echo=F}
hatdt <- read_dta('E:/R_codes/capplot/aggregrate.dta')
```

```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%'}
hatdt <- hatdt %>% 
  filter(type=='个人收入（元）') %>% 
  drop_na(agem,inc,fswt_nat)

set.seed(20191001)
sample <- sample(1:nrow(hatdt),600,replace = F)
sampled <- hatdt[sample,]

plota <- ggplot(hatdt,aes(agem,inc,weight=fswt_nat)) +
  geom_jitter(data=sampled,height=550,width=5,
              size =1.5,alpha=1/3) +
  geom_smooth(span =10,size=1) + 
  geom_smooth(method='lm',size=1,color='red') +
  ylim(0, 20000) +
  labs(x = "年龄",y = "人民币(元）") +
  theme_bw()

plotb <- ggplot() +
  geom_jitter(data=sampled,aes(agem,inc),
              height=550,width=5,size =1.5,alpha=1/3) +
  geom_quantile(data=hatdt,
  aes(agem,inc,weight=fswt_nat),
  size=1,color='red')+
  ylim(0, 20000) +
  labs(x = "年龄",y = "人民币(元）") +
  theme_bw()
```

```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%',fig.showtext= T,fig.asp=0.5,fig.cap='个人收入与年龄。左图：红线为线性回归模型。蓝色曲线为非参数回归。右图：三条线分别是分位数回归。高收入者收入随年龄下降的速度快于低收入者。可将中位数回归与左图线性回归相比较，观测其中的差异。'}

plot_grid(plota,plotb,ncol = 2)

```

# 多项式回归

```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%',fig.showtext= T,fig.cap='对一个模拟数据进行二次项回归。'}
set.seed(2019)
x <- seq(0,4,length=100)
y <- -x^2 + 3*x + jitter(rep(5:9,each =20),2) +3
df <- data.frame(x,y)

reg <- lm(y ~ x + I(x^2),df)

grid <- df %>%
data_grid(x) %>%
gather_predictions(reg)

ggplot(df,aes(x,y))+
  geom_point(size =2,alpha=1/3)+
  geom_line(data=grid,aes(x,pred),size=1,color='blue')+
  theme_bw()
```

下面使用多项式回归拟合CFPS数据:

$$y = {\alpha _0} + {\alpha _1}{x_1} + {\alpha _2}x_1^2$$
$$y = {\alpha _0} + {\alpha _1}{x_1} + {\alpha _2}x_1^2 + {\alpha _3}x_1^3$$



```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%',fig.showtext= T,fig.asp=0.6,fig.cap=' 分别对CFPS数据进行二次项和三次项回归。三次项导致了过拟合。'}
mtrga <- lm(inc~agem+I(agem^2),hatdt)
mtrgb <- lm(inc~agem+I(agem^2)+I(agem^3),hatdt)

grid <- hatdt %>%
data_grid(agem) %>%
gather_predictions(mtrga,mtrgb)

ggplot() +
  geom_jitter(data=sampled,aes(agem,inc),
              height=550,width=5,size =1.5,alpha=1/3) +
  geom_line(data=grid,aes(agem,pred),
            size=1,color='blue')+
  facet_wrap(~model) +
  ylim(0, 20000) +
  labs(x = "年龄",y = "人民币(元）") +
  theme_bw()
```



# 交互项
交互项是计量经济学和应用统计学常用的机制分析技术。公式如下：

$$y = {\alpha _0} + {\alpha _1}{x_1} + {\alpha _2}{x_2} + {\alpha _3}{x_1}{x_2}$$

```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%',fig.asp=0.5,fig.cap='谢益辉的交互效应表示方法。左图：$y = 2 + x + 0.5 z + 0.5 x z + \\epsilon$。右图：$y = 2 + x + 0.5 z + \\epsilon$。圆圈面积表示因变量$y$的大小；坐标轴分别表示自变量$x$和$z$。'}
par(mar = c(4,4,1,0.5), mfrow = c(1, 2), cex.main = 1)
sq = 1:10
x = rep(sq, 10)
z = rep(sq, each = 10)
y = c(outer(sq, sq, function(x, z) 2 + x + 0.5 *
z + 0.5 * x * z + runif(1)))
symbols(x, z, y, bg = rgb(0, 1, 0, 0.3), fg = "blue",
main = "",
inches = 0.4)
y = c(outer(sq, sq, function(x, z) 2 + x + 0.5 *
z + runif(1)))
symbols(x, z, y, bg = rgb(0, 1, 0, 0.3), fg = "blue",
main = "", inches = 0.2)
```

下面使用R自带数据，1994年加拿大劳动与收入动态调查(SLID)。详细信息请在R中输入`?carData::SLID`查看。

## 分类变量与连续变量交互

因变量为收入。自变量为教育年限(年)和使用的语言(英语、法语、其他)。下面分别展示了没有交互项和有交互项的模型。


```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%',fig.showtext= T,fig.asp=0.6,fig.cap='左图：语言不与教育年限交互。不同语言使用者的斜率相同但截距不同。右图：交互模型，英语使用者的工资随教育回报率更高，假定其他条件不变。英语使用者在15年处超越了其他语言使用者。'}
#?carData::SLID
data(SLID,package = 'carData')
SLID <- SLID %>% drop_na()

mod1 <- lm(wages ~ education + language,SLID)
mod2 <- lm(wages ~ education * language,SLID)

grid <- SLID %>%
data_grid(education,language) %>%
gather_predictions(mod1,mod2)

ggplot(SLID,aes(education,wages))+
  geom_jitter(size=1,width=2,height=10,alpha=1/7)+
  geom_line(data=grid,
            aes(education,pred,color=language),size=1)+
  facet_wrap(~model)+
  xlim(0,25)+ ylim(0,40)+
  theme_bw()
```


## 两个连续变量交互

对两个连续交互变量的可视化是一个难题。较好的解决办法是分箱。使用`modelr`的`seq_range`函数对其中一个连续变量进行分箱。

```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%',fig.showtext= T,fig.asp=0.6,fig.cap='无交互效应和有交互效应的区别： 左图体现了不同年龄段者的教育回报率相同(斜率相同)。右图体现了一个因素的大小随着另一个因素的变化而变化。随着年龄的升高教育回报率也在升高。'}
mod1 <- lm(wages ~ education + age,SLID)
mod2 <- lm(wages ~ education * age,SLID)

grid <- SLID %>%
data_grid(education,age = seq_range(age, 5)) %>%
gather_predictions(mod1,mod2)

ggplot(SLID,aes(education,wages))+
  geom_jitter(size=1,width=2,
              height=10,alpha=1/7)+
  geom_line(data=grid,aes(education,pred,
                          color=age,group=age),size=1)+
  facet_wrap(~model)+
  xlim(0,25)+ ylim(0,40)+
  theme_bw()
```

来个负相关的：

```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%',fig.showtext= T,fig.asp=0.6,results='asis',fig.cap='左图无交互效应，可视为控制变量。右图为两个连续变量的交互效应'}
data(freeny)
partial <- lm(y~lag.quarterly.revenue+price.index+
                income.level+market.potential,freeny)

modela <- lm(y~price.index+market.potential,freeny)
modelb <- lm(y~price.index*market.potential,freeny)

stargazer(modela,modelb,partial,
          title='回归结果',
          dep.var.caption='',
          dep.var.labels='Quarterly Revenue',
          header=F,keep.stat=c('n','rsq'), 
         no.space=T,type='html',align=T)

gridt <- freeny %>% 
  data_grid(price.index,
            market.potential=
            seq_range(market.potential,5)) %>%
  gather_predictions(modela,modelb)


ggplot(freeny,aes(price.index,y,
                  color=market.potential))+
  geom_point()+
  geom_line(data=gridt,aes(price.index,pred,
color=market.potential,
group=market.potential))+
  facet_wrap(~model)+
  theme_bw()
```

# 局部加权回归散点平滑

+ Locally Weighted Scatterplot Smoother，LOWESS

$${y_i} = g({x_i}) + {\varepsilon _i}$$
$g$是在$x$带宽$\alpha$范围内进行的多项式回归。

```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%',fig.asp=0.6,fig.cap='使用R自带作图工具绘图。左图：设置不同带宽进行LOWESS回归。右图：Bootstrap重抽样200次的结果。'}
data(PlantCounts,package = 'MSG')
par(mar = c(4,4,1,0.5), mfrow = c(1, 2), pch = 20)
with(PlantCounts, {
plot(altitude, counts, col = rgb(0, 0, 0, 0.3),
panel.first = grid())
for (i in seq(0.01, 1, length = 70)) {
lines(lowess(altitude, counts, f = i),
      col = rgb(0.4,i, 0.4), lwd = 1.5)
 }
plot(altitude, counts, col = rgb(0, 0, 0, 0.3))
for (i in 1:200) {
idx = sample(nrow(PlantCounts), 300, T)
lines(lowess(altitude[idx], counts[idx]),
col = rgb(0, 0, 0, 0.1), lwd = 1.5)
}
})
```

+ `ggplot2`版本

```{r,message=F,warning=F,error=T,comment=NA,cache=T,fig.align='center',out.width='90%',fig.asp=1.2,fig.cap='使用`ggplot2`和`for`循环绘图'}
g <- ggplot(PlantCounts,
            aes(altitude,counts)) +
  geom_point(size=1.5,alpha=1/3) +
  ylim(0,80)+
  theme_bw()

for (i in seq(1,1000,10)){
  col = rgb(0.4,i/1000,0.4)
  g <- g + stat_smooth(geom='line',
                       span=i/1000,
                       size=0.5,
                       se=F,color=col)
}

f <- ggplot(PlantCounts,
            aes(altitude, counts)) +
  geom_point(size=1.5,alpha=1/3) +
  ylim(0,80)+
  theme_bw()

for (i in 1:200) {
idx <- sample(nrow(PlantCounts),300,T)
df <- PlantCounts[idx,]
f <- f + stat_smooth(geom='line',
                     data=df,
                     aes(altitude,counts),
                     span=1,size=0.5,
                     se=F,alpha=1/10)
}

e <- ggplot(PlantCounts,
            aes(altitude, counts)) +
  geom_point(size=1.5,alpha=1/3) +
  geom_smooth(span=1,size=1)+
  ylim(0,80)+
  theme_bw()
plot_grid(g,f,e,ncol = 2)
```


# 样条 

+ Splines

```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',out.width='100%',fig.asp=0.6,fig.cap='左图：1次项样条。右图：3次项样条'}
library(ISLR)
library(splines)
data(wage,package = 'ISLR')
fita <- lm(wage ~ bs(age,degree=1,knots = c(25,40,60)),Wage)
fitb <- lm(wage ~ bs(age,knots = c(25,40,60)),Wage)
summary(fita)
summary(fitb)

grid <- Wage %>% 
  data_grid(age) %>%
  gather_predictions(fita,fitb)

ggplot(Wage,aes(age,wage))+
  geom_point(size=1,alpha=1/7)+
  geom_line(data=grid,aes(age,pred),
            size=1,color='purple')+
  facet_wrap(~model)+
  theme_bw()
```


# Box-Cox 变换

为保证变量的正态性进行的统计学转换。

$$
{y(\lambda)}=\left\{
\begin{aligned}
{\textstyle{{{y^\lambda } - 1} \over \lambda }} & , & \mbox{if}\quad\lambda\ne 0 \\
\log y & , & \mbox{if}\quad\lambda = 0
\end{aligned}
\right.
$$  


$$
{y(\lambda)}=\left\{
\begin{aligned}
{\textstyle{{{{(y + {\lambda _2})}^{{\lambda _1}}} - 1} \over {{\lambda _1}}}} & , & \mbox{if}\quad\lambda_1\ne 0 \\
\log (y + {\lambda _2}{\rm{)}} & , & \mbox{if}\quad\lambda_1 = 0
\end{aligned}
\right.
$$


```{r,message=F,warning=F,error=T,comment=NA,fig.align='center',fig.asp=0.5,out.width='90%',fig.cap=' '}
library(MASS)
x = rf(500,30,30)
boxa <- ggplot(as.data.frame(x),aes(x))+
  geom_histogram(color='black',
                 fill='white') 

result = boxcox(x~1,lambda = seq(-0.5,0,5))
mylambda = result$x[which.max(result$y)]
mylambda
x2 <- (x^mylambda-1)/mylambda
x2 = as.data.frame(x2)

boxb <- ggplot(x2,aes(x2)) +
  geom_histogram(color='black',
                 fill='white') 
plot_grid(boxa,boxb,ncol = 2)
```


























