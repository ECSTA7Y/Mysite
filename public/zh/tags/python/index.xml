<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Xiao Song</title>
    <link>/zh/tags/python/</link>
    <description>Recent content in Python on Xiao Song</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 11 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/zh/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Python有用的函数</title>
      <link>/zh/pybasic/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/zh/pybasic/</guid>
      <description>从文件中读取数据文件类提供了三种方法读取文本文件的内容，分别是：
f.read(size)返回一个字符串，内容为长度为size的文本。参数size表示读取的数扯，可以省略。如果省略size参数，则表示读取文件所有内容，作为一个字符串返回。
f.readline()返回一个字符串，内容为文件当前一行的文本。
f.readlines()返回一个列表，列表的数据项为一行的文本[linel, line2, ···,lineN] 。再通过循环操作可以逐行访问列表中每一行的内容。
mode解释r以只读方式打开w以写方式打开一个文件，当这个文件存在时，覆盖原来的内容。当这个文件不存在时，创建这个文件x创建一个新文件，以写方式打开，当文件已存在， 报错FileExistsErrora以写方式打开，写人内容追加在文件的末尾b表示二进制文件，添加在其他控制字符后t表示文本文件，默认值+以修改方式打开，支持读写设置工作目录获取当前工作目录：import osos.getcwd(&amp;#39; &amp;#39;) 设置工作目录os.</description>
    </item>
    
    <item>
      <title>NBA球员薪资分析：基于AdaBoost算法的Python实战</title>
      <link>/zh/nba/</link>
      <pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/zh/nba/</guid>
      <description>页面跳转中···
window.location.replace(&#34;https://xsong.ltd/archives/pandas/nba&#34;)</description>
    </item>
    
    <item>
      <title>Python面向对象基础</title>
      <link>/zh/pyobject/</link>
      <pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/zh/pyobject/</guid>
      <description>class Dog:def bark(self):print(&amp;quot;woo woo woo&amp;quot;)dog1=Dog()dog1.bark()woo woo wooclass Dog:def bark(self,xm):self.name = xmprint(&amp;quot;woo woo woo, I am &amp;quot;+self.name)dog1=Dog()dog1.bark(&amp;quot;Lulu&amp;quot;) woo woo woo, I am Lulu##__init__()方法class Dog:def __init__(self,name,color):self.name = nameself.color = colordef bark(self):print(&amp;quot;woo,woo,woo,我是&amp;quot;+ self.name +&amp;quot;!&amp;quot;)dog1 = Dog(&amp;quot;阿黄&amp;quot;,&amp;quot;黄色&amp;quot;)dog1.bark()#print(&amp;quot;刚才创建了一个狗对象，名叫：&amp;quot;+dog1.name+&amp;quot;!&amp;quot;)#bark()woo,woo,woo,我是阿黄!dog1 = Dog(&amp;quot;阿黄&amp;quot;,&amp;quot;黄色&amp;quot;)class Dog:number = 0def __init__(self,name):self.name = nameDog.</description>
    </item>
    
    <item>
      <title>排序和查找算法(Python实现)</title>
      <link>/zh/suanfa/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/zh/suanfa/</guid>
      <description>排序算法冒泡排序法def bubble(List):for j in range(len(List)-1,0,-1):print(List)for i in range(0,j):if List[i]&amp;gt;List[i+1]:List[i],List[i+1] = List[i+1],List[i]return List testlist = [49,38,65,97,76,13,27,49]print(&amp;#39;结果：&amp;#39;,bubble(testlist))[49, 38, 65, 97, 76, 13, 27, 49][38, 49, 65, 76, 13, 27, 49, 97][38, 49, 65, 13, 27, 49, 76, 97][38, 49, 13, 27, 49, 65, 76, 97][38, 13, 27, 49, 49, 65, 76, 97][13, 27, 38, 49, 49, 65, 76, 97][13, 27, 38, 49, 49, 65, 76, 97]结果： [13, 27, 38, 49, 49, 65, 76, 97]选择排序算法#选择排序算法：程序填空def selection_sort(L):N = len(L) #提取列表长度Nexchange_count = 0for i in range(0, N-1): #从0开始循环min_index = i #排序序列的末尾位置for j in range(i+1,N): #嵌套循环if L[min_index] &amp;gt; L[j]: #第一次循环L[0]&amp;gt;L[1] min_index = j #第一次循环min_index=1 j是二者最小值的列表索引。 #min_index永远等于最小值索引#以下是移动程序if min_index!</description>
    </item>
    
  </channel>
</rss>